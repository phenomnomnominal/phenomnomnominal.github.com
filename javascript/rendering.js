// Generated by CoffeeScript 1.6.2
(function() {
  (typeof exports !== "undefined" && exports !== null ? exports : this).Rendering = (function() {
    var ASPECT_RATIO, FAR_Z, FIELD_OF_VIEW, NEAR_Z, SIX_AM, SIX_PM, init, initProject, killProject, setLightTarget, setRendererSize, toggleDebug, update, _camera, _initCamera, _initLights, _initShadow, _lights, _makeLight, _nighttime, _project, _renderer, _scene;

    FIELD_OF_VIEW = 70;
    ASPECT_RATIO = 16 / 9;
    NEAR_Z = 0.01;
    FAR_Z = 800;
    SIX_AM = 6;
    SIX_PM = 18;
    _scene = new THREE.Scene();
    _renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    _camera = new THREE.PerspectiveCamera(FIELD_OF_VIEW, ASPECT_RATIO, NEAR_Z, FAR_Z);
    _lights = [];
    _nighttime = false;
    _project = false;
    _initShadow = function() {
      _renderer.shadowMapEnabled = true;
      _renderer.shadowCameraNear = NEAR_Z;
      _renderer.shadowCameraFar = FAR_Z;
      _renderer.shadowCameraFov = FIELD_OF_VIEW;
      _renderer.shadowMapDarkness = 1;
      _renderer.shadowMapWidth = 256;
      return _renderer.shadowMapHeight = 256;
    };
    _initCamera = function() {
      _camera.position = new THREE.Vector3(960, 540, 772);
      return _camera.lookAt(new THREE.Vector3(960, 540, 0));
    };
    _makeLight = function(colour, position) {
      var light;

      light = _nighttime ? new THREE.SpotLight(colour, 2.5) : new THREE.DirectionalLight(colour);
      light.position = position;
      light.target.position = new THREE.Vector3(960, 540, 10);
      light.castShadow = true;
      light.shadowCameraVisible = Main.debug;
      _lights.push(light);
      return _scene.add(light);
    };
    _initLights = function() {
      _nighttime = new Date().getHours() < SIX_AM || new Date().getHours() > SIX_PM;
      if (_nighttime) {
        _renderer.setClearColor(Colours.background.night, 1);
        _makeLight(Colours.light.night, new THREE.Vector3(0, 1080, 250));
        return _makeLight(Colours.light.night, new THREE.Vector3(1920, 1080, 250));
      } else {
        _renderer.setClearColor(Colours.background.day, 0);
        _makeLight(Colours.light.day, new THREE.Vector3(-200, 1080, 700));
        return _makeLight(Colours.light.day, new THREE.Vector3(2120, 1080, 700));
      }
    };
    init = function() {
      _initShadow();
      _initCamera();
      _initLights();
      $('main').append(_renderer.domElement);
      setRendererSize(Events.get.screenSize());
      return [_scene, _camera];
    };
    setLightTarget = function(position) {
      if (!_project) {
        return _.each(_lights, function(light) {
          return light.target.position = position;
        });
      }
    };
    setRendererSize = function(screenSize) {
      return _renderer.setSize.apply(_renderer, screenSize);
    };
    toggleDebug = function() {
      return _.each(_scene.children, function(child) {
        if (child instanceof THREE.DirectionalLight) {
          child.shadowCameraVisible = Main.debug;
        } else if (child.material != null) {
          child.material.wireframe = Main.debug;
        }
        return _.each(child.children, function(letter) {
          if (letter.material != null) {
            return letter.material.wireframe = Main.debug;
          }
        });
      });
    };
    update = function() {
      if (!_project) {
        return _renderer.render(_scene, _camera);
      }
    };
    initProject = function() {
      _.each(_lights, function(light) {
        return light.target.position = new THREE.Vector3(960, 540, 0);
      });
      return _project = true;
    };
    killProject = function() {
      return _project = false;
    };
    return {
      init: init,
      initProject: initProject,
      killProject: killProject,
      setLightTarget: setLightTarget,
      setRendererSize: setRendererSize,
      toggleDebug: toggleDebug,
      update: update
    };
  })();

}).call(this);
