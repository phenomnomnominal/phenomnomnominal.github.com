// Generated by CoffeeScript 1.3.3
(function() {
  var CAMERA, CloudCA, Clouds, RENDERER, SCENE_BACK, SCENE_FRONT, maxWeight, pAct, pExt, pHum, root, start_time, windSpeed, x, xSmooth, y, ySmooth, z, zSmooth, _i, _j, _k;

  pExt = 0.1;

  pAct = 0.001;

  pHum = 0.1;

  windSpeed = 1;

  xSmooth = 2;

  ySmooth = 2;

  zSmooth = 2;

  maxWeight = 0;

  for (x = _i = -xSmooth; -xSmooth <= xSmooth ? _i <= xSmooth : _i >= xSmooth; x = -xSmooth <= xSmooth ? ++_i : --_i) {
    for (y = _j = -ySmooth; -ySmooth <= ySmooth ? _j <= ySmooth : _j >= ySmooth; y = -ySmooth <= ySmooth ? ++_j : --_j) {
      for (z = _k = -zSmooth; -zSmooth <= zSmooth ? _k <= zSmooth : _k >= zSmooth; z = -zSmooth <= zSmooth ? ++_k : --_k) {
        maxWeight += Math.sqrt((x * x) + (y * y) + (z * z));
      }
    }
  }

  start_time = null;

  RENDERER = null;

  SCENE_BACK = null;

  SCENE_FRONT = null;

  CAMERA = null;

  Clouds = function() {
    var $container, Lerp, animate, bounds, cloudDensity, clouds, fog, genCount, geometry, height, i, material, oldMeshBack, oldMeshFront, plane, positions, render, rotations, subBounds, texture, width, _l;
    width = $(window).innerWidth();
    height = $(window).innerHeight();
    start_time = new Date().getTime();
    $container = $('.clouds div');
    RENDERER = new THREE.WebGLRenderer({
      antialias: false
    });
    RENDERER.setSize(width, height);
    RENDERER.autoClear = false;
    $container.append(RENDERER.domElement);
    SCENE_BACK = new THREE.Scene();
    SCENE_FRONT = new THREE.Scene();
    CAMERA = new THREE.PerspectiveCamera(45, width / height, 1, 100000);
    CAMERA.position.y = 100;
    CAMERA.position.z = 8000;
    SCENE_BACK.add(CAMERA);
    SCENE_FRONT.add(CAMERA);
    texture = THREE.ImageUtils.loadTexture('images/cloudTexture.png');
    texture.magFilter = THREE.LinearMipMapLinearFilter;
    texture.minFilter = THREE.LinearMipMapLinearFilter;
    fog = new THREE.Fog(0x4584b4, 1, 8000);
    material = new THREE.ShaderMaterial({
      uniforms: {
        'map': {
          type: 't',
          value: texture
        },
        'fogColor': {
          type: 'c',
          value: fog.color
        },
        'fogNear': {
          type: 'f',
          value: fog.near
        },
        'fogFar': {
          type: 'f',
          value: fog.far
        }
      },
      vertexShader: $('#vs').text(),
      fragmentShader: $('#fs').text(),
      depthTest: false
    });
    plane = new THREE.Mesh(new THREE.PlaneGeometry(64, 64));
    geometry = new THREE.Geometry();
    for (i = _l = 0; _l < 8000; i = ++_l) {
      plane.position.x = Math.random() * 1000 - 500;
      plane.position.y = -Math.random() * Math.random() * 50 - 15;
      plane.position.z = i;
      plane.rotation.z = Math.random() * Math.PI;
      plane.scale.x = plane.scale.y = Math.random() * Math.random() * 1.5 + 0.5;
      THREE.GeometryUtils.merge(geometry, plane);
    }
    clouds = new CloudCA(20, 4, 20);
    bounds = clouds.createBounds(geometry);
    subBounds = clouds.createSubBounds(geometry);
    $(window).resize(function() {
      width = $(window).innerWidth();
      height = $(window).innerHeight();
      CAMERA.aspect = width / height;
      CAMERA.updateProjectionMatrix();
      return RENDERER.setSize(width, height);
    });
    $(window).trigger('resize');
    Lerp = function(x, y, s) {
      return x * (1 - s) + (y * s);
    };
    genCount = 0;
    oldMeshFront = null;
    oldMeshBack = null;
    cloudDensity = null;
    rotations = [];
    positions = [];
    animate = function() {
      var meshBack, meshFront, pos, scale, _m, _n, _o, _ref, _ref1, _ref2;
      if (genCount % 500 === 0) {
        cloudDensity = clouds.getGeneration();
      }
      geometry = new THREE.Geometry();
      for (x = _m = 0, _ref = clouds.x; 0 <= _ref ? _m < _ref : _m > _ref; x = 0 <= _ref ? ++_m : --_m) {
        for (y = _n = 0, _ref1 = clouds.y; 0 <= _ref1 ? _n < _ref1 : _n > _ref1; y = 0 <= _ref1 ? ++_n : --_n) {
          for (z = _o = 0, _ref2 = clouds.z; 0 <= _ref2 ? _o < _ref2 : _o > _ref2; z = 0 <= _ref2 ? ++_o : --_o) {
            i = (x * clouds.y * clouds.z) + (y * clouds.z) + z;
            scale = Lerp(cloudDensity.current[x][y][z], cloudDensity.next[x][y][z], (genCount % 500) / 500) * 200;
            if (scale !== 0) {
              if (!(rotations[i] != null)) {
                rotations[i] = Math.random() * Math.PI;
                pos = subBounds.children[i].position;
                positions[i] = new THREE.Vector3(pos.x + Math.random() * 10, pos.y + Math.random() * 10, pos.z + Math.random() * 10);
              }
              plane.rotation.z = rotations[i];
              plane.position = positions[i];
              plane.renderDepth = -z;
              plane.scale.x = plane.scale.y = scale;
              THREE.GeometryUtils.merge(geometry, plane);
            }
          }
        }
        meshFront = new THREE.Mesh(geometry, material);
      }
      SCENE_FRONT.remove(oldMeshFront);
      SCENE_FRONT.add(meshFront);
      oldMeshFront = meshFront;
      meshBack = new THREE.Mesh(geometry, material);
      meshBack.position.z = -8000;
      SCENE_BACK.remove(oldMeshBack);
      SCENE_BACK.add(meshBack);
      oldMeshBack = meshBack;
      requestAnimFrame(animate);
      render();
      return genCount++;
    };
    render = function() {
      var position;
      RENDERER.clear();
      position = ((new Date().getTime() - start_time) * 0.03) % 8000;
      CAMERA.position.z = -position + 8000;
      RENDERER.render(SCENE_BACK, CAMERA);
      return RENDERER.render(SCENE_FRONT, CAMERA);
    };
    return animate();
  };

  CloudCA = (function() {
    var extinction, getDensity, growth, logic, neighboursAct, process, toGrid;

    function CloudCA(x, y, z, t) {
      var i, _l, _ref;
      this.x = x;
      this.y = y;
      this.z = z;
      this.t = t != null ? t : 0;
      this.size = this.x * this.y * this.z;
      this._ = {
        gen: {
          hum: '',
          act: '',
          cld: ''
        },
        clouds: null
      };
      this.density = {
        curr: null,
        next: null
      };
      for (i = _l = 0, _ref = this.size; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
        this._.gen.hum += Math.random() > 0.5 ? '1' : '0';
        this._.gen.act += Math.random() > 0.5 ? '1' : '0';
        this._.gen.cld += 0;
      }
      this._.clouds = toGrid.call(this, (function(x, y, z) {
        return +this._.gen.cld[x * this.x + y * this.y + z];
      }));
      this.density.next = toGrid.call(this, (function(x, y, z) {
        return getDensity(this._.clouds, x, y, z);
      }));
      this.getGeneration();
    }

    CloudCA.prototype.createBounds = function(geometry) {
      var material, mesh;
      geometry.computeBoundingBox();
      this._.bounds = geometry.boundingBox;
      this._.scale = {
        x: this._.bounds.max.x - this._.bounds.min.x,
        y: this._.bounds.max.y - this._.bounds.min.y,
        z: this._.bounds.max.z - this._.bounds.min.z
      };
      geometry = new THREE.CubeGeometry(this._.scale.x, this._.scale.y, this._.scale.z);
      material = new THREE.MeshBasicMaterial({
        color: 0x0000FF,
        wireframe: true
      });
      mesh = new THREE.Mesh(geometry, material);
      mesh.position.x = this._.bounds.min.x + this._.scale.x / 2;
      mesh.position.y = this._.bounds.min.y + this._.scale.y / 2;
      mesh.position.z = this._.bounds.min.z + this._.scale.z / 2;
      return mesh;
    };

    CloudCA.prototype.createSubBounds = function() {
      var cube, dx, dy, dz, group, material, subBound, subScaleX, subScaleY, subScaleZ, _l, _m, _n, _ref, _ref1, _ref2;
      dx = (this._.bounds.max.x - this._.bounds.min.x) / this.x;
      dy = (this._.bounds.max.y - this._.bounds.min.y) / this.y;
      dz = (this._.bounds.max.z - this._.bounds.min.z) / this.z;
      subScaleX = this._.scale.x / this.x;
      subScaleY = this._.scale.y / this.y;
      subScaleZ = this._.scale.z / this.z;
      group = new THREE.Object3D();
      material = new THREE.MeshBasicMaterial({
        color: 0x00FF00,
        wireframe: true
      });
      cube = new THREE.CubeGeometry(subScaleX, subScaleY, subScaleZ);
      for (x = _l = 0, _ref = this.x; 0 <= _ref ? _l < _ref : _l > _ref; x = 0 <= _ref ? ++_l : --_l) {
        for (y = _m = 0, _ref1 = this.y; 0 <= _ref1 ? _m < _ref1 : _m > _ref1; y = 0 <= _ref1 ? ++_m : --_m) {
          for (z = _n = 0, _ref2 = this.z; 0 <= _ref2 ? _n < _ref2 : _n > _ref2; z = 0 <= _ref2 ? ++_n : --_n) {
            subBound = new THREE.Mesh(cube, material);
            subBound.position.x = this._.bounds.min.x + (subScaleX * (x + 0.5));
            subBound.position.y = this._.bounds.min.y + (subScaleY * (y + 0.5));
            subBound.position.z = this._.bounds.min.z + (subScaleZ * (z + 0.5));
            group.add(subBound);
          }
        }
      }
      return group;
    };

    CloudCA.prototype.getGeneration = function() {
      var currDen;
      currDen = this.density.next;
      this._.gen = process.call(this, this._.gen, growth);
      this._.gen = process.call(this, this._.gen, extinction);
      this._.clouds = toGrid.call(this, (function(x, y, z) {
        return +this._.gen.cld[x * this.x + y * this.y + z];
      }));
      return this.density = {
        current: currDen,
        next: toGrid.call(this, (function(x, y, z) {
          return getDensity(this._.clouds, x, y, z);
        }))
      };
    };

    logic = {
      and: function(str1, str2, res) {
        var i, _l, _ref;
        if (res == null) {
          res = '';
        }
        for (i = _l = 0, _ref = str1.length; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
          res += "" + (str1[i] & str2[i]);
        }
        return res;
      },
      or: function(str1, str2, res) {
        var i, _l, _ref;
        if (res == null) {
          res = '';
        }
        for (i = _l = 0, _ref = str1.length; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
          res += "" + (str1[i] | str2[i]);
        }
        return res;
      },
      not: function(str, res) {
        var i, _l, _ref;
        if (res == null) {
          res = '';
        }
        for (i = _l = 0, _ref = str.length; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
          res += str[i] === '0' ? '1' : '0';
        }
        return res;
      }
    };

    toGrid = function(func) {
      var g, _base, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4;
      g = [];
      for (x = _l = 0, _ref = this.x; 0 <= _ref ? _l < _ref : _l > _ref; x = 0 <= _ref ? ++_l : --_l) {
        if ((_ref1 = g[x]) == null) {
          g[x] = [];
        }
        for (y = _m = 0, _ref2 = this.y; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; y = 0 <= _ref2 ? ++_m : --_m) {
          if ((_ref3 = (_base = g[x])[y]) == null) {
            _base[y] = [];
          }
          for (z = _n = 0, _ref4 = this.z; 0 <= _ref4 ? _n < _ref4 : _n > _ref4; z = 0 <= _ref4 ? ++_n : --_n) {
            g[x][y][z] = func.call(this, x, y, z);
          }
        }
      }
      return g;
    };

    process = function(gen, func, newHum, newAct, newCld) {
      var _ref;
      if (newHum == null) {
        newHum = '';
      }
      if (newAct == null) {
        newAct = '';
      }
      if (newCld == null) {
        newCld = '';
      }
      _ref = func.call(this, gen), newHum = _ref[0], newAct = _ref[1], newCld = _ref[2];
      return {
        hum: newHum,
        act: newAct,
        cld: newCld
      };
    };

    growth = function(gen, nAct) {
      var act, actGrid, cld, hum, newAct, newCld, newHum;
      if (nAct == null) {
        nAct = '';
      }
      hum = gen.hum, act = gen.act, cld = gen.cld;
      actGrid = toGrid.call(this, (function(x, y, z) {
        return +act[x * this.x + y * this.y + z];
      }));
      nAct = neighboursAct.call(this, actGrid);
      newHum = logic.and(hum, logic.not(act));
      newAct = logic.and(newHum, nAct);
      newCld = logic.or(cld, act);
      return [newHum, newAct, newCld];
    };

    neighboursAct = function(grid, str) {
      var neighbourAct, _l, _m, _n, _ref, _ref1, _ref2;
      if (str == null) {
        str = '';
      }
      neighbourAct = function(grid, x, y, z) {
        var _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        return ((_ref = grid[x + 1]) != null ? (_ref1 = _ref[y]) != null ? _ref1[z] : void 0 : void 0) || ((_ref2 = grid[x]) != null ? (_ref3 = _ref2[y + 1]) != null ? _ref3[z] : void 0 : void 0) || ((_ref4 = grid[x]) != null ? (_ref5 = _ref4[y]) != null ? _ref5[z + 1] : void 0 : void 0) || ((_ref6 = grid[x - 1]) != null ? (_ref7 = _ref6[y]) != null ? _ref7[z] : void 0 : void 0) || ((_ref8 = grid[x]) != null ? (_ref9 = _ref8[y - 1]) != null ? _ref9[z] : void 0 : void 0) || ((_ref10 = grid[x]) != null ? (_ref11 = _ref10[y]) != null ? _ref11[z - 1] : void 0 : void 0) || ((_ref12 = grid[x - 2]) != null ? (_ref13 = _ref12[y]) != null ? _ref13[z] : void 0 : void 0) || ((_ref14 = grid[x + 2]) != null ? (_ref15 = _ref14[y]) != null ? _ref15[z] : void 0 : void 0) || ((_ref16 = grid[x]) != null ? (_ref17 = _ref16[y - 2]) != null ? _ref17[z] : void 0 : void 0) || ((_ref18 = grid[x]) != null ? (_ref19 = _ref18[y + 2]) != null ? _ref19[z] : void 0 : void 0) || ((_ref20 = grid[x]) != null ? (_ref21 = _ref20[y]) != null ? _ref21[z - 2] : void 0 : void 0);
      };
      for (x = _l = 0, _ref = this.x; 0 <= _ref ? _l < _ref : _l > _ref; x = 0 <= _ref ? ++_l : --_l) {
        for (y = _m = 0, _ref1 = this.y; 0 <= _ref1 ? _m < _ref1 : _m > _ref1; y = 0 <= _ref1 ? ++_m : --_m) {
          for (z = _n = 0, _ref2 = this.z; 0 <= _ref2 ? _n < _ref2 : _n > _ref2; z = 0 <= _ref2 ? ++_n : --_n) {
            str += neighbourAct(grid, x, y, z) ? '1' : '0';
          }
        }
      }
      return str;
    };

    extinction = function(gen, randHum, randAct, randCld) {
      var act, cld, hum, i, newAct, newCld, newHum, _l, _m, _n, _ref, _ref1, _ref2;
      if (randHum == null) {
        randHum = '';
      }
      if (randAct == null) {
        randAct = '';
      }
      if (randCld == null) {
        randCld = '';
      }
      hum = gen.hum, act = gen.act, cld = gen.cld;
      for (i = _l = 0, _ref = this.size; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
        randHum += Math.random() < pHum ? '1' : '0';
      }
      for (i = _m = 0, _ref1 = this.size; 0 <= _ref1 ? _m < _ref1 : _m > _ref1; i = 0 <= _ref1 ? ++_m : --_m) {
        randAct += Math.random() < pAct ? '1' : '0';
      }
      for (i = _n = 0, _ref2 = this.size; 0 <= _ref2 ? _n < _ref2 : _n > _ref2; i = 0 <= _ref2 ? ++_n : --_n) {
        randCld += Math.random() > pExt ? '1' : '0';
      }
      newHum = logic.or(hum, randHum);
      newAct = logic.or(act, randAct);
      newCld = logic.and(cld, randCld);
      return [newHum, newAct, newCld];
    };

    getDensity = function(clouds, x, y, z) {
      var d, exists, weight, xs, ys, zs, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      weight = function(dx, dy, dz) {
        return Math.sqrt((dx * dx) + (dy * dy) + (dz * dz));
      };
      d = 0;
      if (((_ref = clouds[x]) != null ? (_ref1 = _ref[y]) != null ? _ref1[z] : void 0 : void 0) === 1) {
        for (xs = _l = _ref2 = x - xSmooth, _ref3 = x + xSmooth; _ref2 <= _ref3 ? _l <= _ref3 : _l >= _ref3; xs = _ref2 <= _ref3 ? ++_l : --_l) {
          for (ys = _m = _ref4 = y - ySmooth, _ref5 = y + ySmooth; _ref4 <= _ref5 ? _m <= _ref5 : _m >= _ref5; ys = _ref4 <= _ref5 ? ++_m : --_m) {
            for (zs = _n = _ref6 = z - zSmooth, _ref7 = z + zSmooth; _ref6 <= _ref7 ? _n <= _ref7 : _n >= _ref7; zs = _ref6 <= _ref7 ? ++_n : --_n) {
              exists = ((_ref8 = clouds[xs]) != null ? (_ref9 = _ref8[ys]) != null ? _ref9[zs] : void 0 : void 0) != null;
              d += (exists && clouds[xs][ys][zs] === 1 ? weight(xs - x, ys - x, zs - x) : 0);
            }
          }
        }
      }
      if (d !== 0) {
        d /= maxWeight;
        d /= (2 * xSmooth + 1) * (2 * ySmooth + 1) * (2 * zSmooth + 1);
      } else {
        d = d;
      }
      return d;
    };

    return CloudCA;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Clouds = Clouds;

}).call(this);
