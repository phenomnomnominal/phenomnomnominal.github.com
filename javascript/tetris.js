// Generated by CoffeeScript 1.3.3
(function() {
  var CANVAS, CELL_SIZE, CONTEXT, I, J, L, O, S, T, Tetrimino, TetriminoBag, Tetris, TetrisAI, Z, colours, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  CANVAS = null;

  CONTEXT = null;

  CELL_SIZE = 41.5;

  colours = [null, 'rgb(247,155,50)', 'rgb(244,50,251)', 'rgb(50,50,255)', 'rgb(246,75,50)', 'rgb(255,255,50)', 'rgb(163,253,255)', 'rgb(137,255,50)'];

  Tetris = function() {
    var root, update;
    CANVAS = $('.tetris canvas')[0];
    CONTEXT = CANVAS.getContext('2d');
    CANVAS.height = CELL_SIZE * 20;
    CANVAS.width = CELL_SIZE * 10 + 250;
    root = typeof exports !== "undefined" && exports !== null ? exports : this;
    root.TetrisGame = new TetrisAI();
    TetrisGame.draw();
    update = function() {
      TetrisGame.draw();
      return TetrisGame.update();
    };
    return setInterval(update, 250);
  };

  TetrisAI = (function() {

    function TetrisAI() {
      var x, y, _i, _j;
      this.PreviousTetromino = void 0;
      this.MoveScores = [];
      this.Bag = new TetriminoBag();
      this.Lines = 0;
      this.TotalLines = 0;
      this.Level = 0;
      this.Matrix = [];
      this.MoveCount = 1;
      this.Points = 0;
      this.GameOver = false;
      for (x = _i = 0; _i <= 21; x = ++_i) {
        this.Matrix[x] = [];
        for (y = _j = 0; _j <= 11; y = ++_j) {
          if (y === 0 || y === 11) {
            this.Matrix[x][y] = -3;
          } else if (x === 21) {
            this.Matrix[x][y] = -2;
          } else {
            this.Matrix[x][y] = 0;
          }
        }
      }
      this.CurrentTetromino = this.Bag.getNext();
      this.NextTetromino = this.Bag.getNext();
      return;
    }

    TetrisAI.prototype.getHighestRow = function() {
      var column, row, _i, _j;
      for (row = _i = 1; _i <= 20; row = ++_i) {
        for (column = _j = 1; _j <= 10; column = ++_j) {
          if (this.Matrix[row][column] > 0) {
            return Math.max(1, row - 3);
          }
        }
      }
      return 1;
    };

    TetrisAI.prototype.update = function() {
      var currentDomain, move;
      if (!this.checkLoss()) {
        currentDomain = this.CurrentTetromino.getDomain(this.Matrix);
        move = this.getBestMove(currentDomain);
        this.addDomainValue(this.CurrentTetromino, move.valA, this.Matrix);
        this.score(this.removeLines(this.Matrix));
        this.Points += 20.;
        this.PreviousTetromino = this.CurrentTetromino;
        this.CurrentTetromino = this.NextTetromino;
        this.NextTetromino = this.Bag.getNext();
        this.MoveCount++;
        this.LastMove = move;
      }
    };

    TetrisAI.prototype.getBestMove = function(domainA) {
      var combinedBest, currentState, domainB, domainValueA, domainValueB, linesScoreA, obj, oneAddedState, _i, _j, _len, _len1;
      combinedBest = void 0;
      for (_i = 0, _len = domainA.length; _i < _len; _i++) {
        domainValueA = domainA[_i];
        currentState = this.copyMatrix(this.Matrix);
        if (this.addDomainValue(this.CurrentTetromino, domainValueA, currentState)) {
          linesScoreA = 12 * this.removeLines(currentState);
          domainB = this.NextTetromino.getDomain(currentState);
          for (_j = 0, _len1 = domainB.length; _j < _len1; _j++) {
            domainValueB = domainB[_j];
            oneAddedState = this.copyMatrix(currentState);
            if (this.addDomainValue(this.NextTetromino, domainValueB, oneAddedState)) {
              obj = {
                moveCount: this.MoveCount,
                valA: domainValueA,
                valB: domainValueB,
                score: this.getCombinedScore(linesScoreA, domainValueA, domainValueB, currentState, oneAddedState),
                total: 0
              };
              obj.total = obj.score.total;
              if (combinedBest !== void 0) {
                if (obj.total > combinedBest.total) {
                  combinedBest = obj;
                }
              } else {
                combinedBest = obj;
              }
            }
          }
        }
      }
      this.MoveScores.push(combinedBest);
      return combinedBest;
    };

    TetrisAI.prototype.getCombinedScore = function(linesScoreA, domainValueA, domainValueB, oneAddedMatrix, bothAddedMatrix) {
      var heightScoreA, heightScoreB, holesScoreA, holesScoreB, linesScoreB, score, scoreObj, touchingScoreA, touchingScoreB;
      score = 0;
      score += linesScoreA;
      linesScoreB = 12 * this.removeLines(bothAddedMatrix);
      score += linesScoreB;
      heightScoreA = this.getHeightScore(oneAddedMatrix);
      score += heightScoreA;
      heightScoreB = this.getHeightScore(bothAddedMatrix);
      score += heightScoreB;
      holesScoreA = this.getHolesScore(domainValueA, oneAddedMatrix);
      score += holesScoreA;
      holesScoreB = this.getHolesScore(domainValueB, bothAddedMatrix);
      score += holesScoreB;
      touchingScoreA = this.getTouchingScore(domainValueA, oneAddedMatrix);
      score += touchingScoreA;
      touchingScoreB = this.getTouchingScore(domainValueB, bothAddedMatrix);
      score += touchingScoreB;
      scoreObj = {
        heightA: heightScoreA,
        heightB: heightScoreB,
        holesA: holesScoreA,
        holesB: holesScoreB,
        touchingA: touchingScoreA,
        touchingB: touchingScoreB,
        linesA: linesScoreA,
        linesB: linesScoreB,
        total: score
      };
      return scoreObj;
    };

    TetrisAI.prototype.removeLines = function(matrix) {
      var column, completeLines, ones, row, rowUp, _i, _j, _k;
      completeLines = 0;
      for (row = _i = 20; _i >= 1; row = --_i) {
        ones = 0;
        for (column = _j = 1; _j <= 10; column = ++_j) {
          if (matrix[row][column] > 0) {
            ones++;
          }
        }
        if (ones === 10) {
          for (rowUp = _k = row; row <= 1 ? _k <= 1 : _k >= 1; rowUp = row <= 1 ? ++_k : --_k) {
            if (rowUp > 1) {
              matrix[rowUp] = matrix[rowUp - 1];
            }
          }
          matrix[1] = [-3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3];
          completeLines++;
          row++;
        }
      }
      return completeLines;
    };

    TetrisAI.prototype.getHeightScore = function(matrix) {
      var column, row, score, _i, _j;
      score = 0;
      for (row = _i = 1; _i <= 20; row = ++_i) {
        for (column = _j = 1; _j <= 10; column = ++_j) {
          if (matrix[row][column] > 0) {
            score += 21 - parseInt(row);
          }
        }
      }
      return -0.14 * score;
    };

    TetrisAI.prototype.getHolesScore = function(domainValue, matrix) {
      var blockades, blocks, holes, i, val, x, xVal, y, yVal, _i, _ref, _ref1;
      holes = 0;
      blockades = 0;
      _ref = domainValue.matrix;
      for (x in _ref) {
        if (!__hasProp.call(_ref, x)) continue;
        xVal = _ref[x];
        for (y in xVal) {
          if (!__hasProp.call(xVal, y)) continue;
          yVal = xVal[y];
          blocks = 0;
          if (matrix[x][y] === domainValue.Tetrimino.Colour) {
            blocks++;
          }
          for (i = _i = _ref1 = parseInt(x); _ref1 <= 20 ? _i <= 20 : _i >= 20; i = _ref1 <= 20 ? ++_i : --_i) {
            if (i < 21) {
              val = matrix[i][y];
              if (val === 0 && blocks > 0) {
                blockades += blocks;
                blocks = 0;
                holes++;
              } else if (val > 0) {
                blocks++;
              }
            }
          }
        }
        break;
      }
      return (-8 * holes) + (-2.5 * blockades);
    };

    /*
      function getScore:
          For each block in the shape, sum the touching scores of the blocks.
      @param shape - the Shape of the current domain value to score.
      @param localMatrix - the local area in which the shape will be placed.
      @param globalMatrix - the global Tetris matrix.
      @return score - the total score for this shape.
    */


    TetrisAI.prototype.getTouchingScore = function(domainValue, globalMatrix) {
      var column, columnValue, downScore, localMatrix, row, rowValues, shape, shapeColumn, shapeRow, sideScore;
      localMatrix = domainValue.matrix;
      shape = domainValue.Shape;
      downScore = 0;
      sideScore = 0;
      shapeRow = 0;
      for (row in localMatrix) {
        if (!__hasProp.call(localMatrix, row)) continue;
        rowValues = localMatrix[row];
        shapeColumn = 0;
        for (column in rowValues) {
          if (!__hasProp.call(rowValues, column)) continue;
          columnValue = rowValues[column];
          if (columnValue === domainValue.Tetrimino.Colour && shape[shapeRow][shapeColumn] === 1) {
            downScore += this.getDownTouchingScore(globalMatrix, parseInt(row), parseInt(column), shape, shapeRow, shapeColumn);
            sideScore += this.getSideTouchingScore(globalMatrix, parseInt(row), parseInt(column), shape, shapeRow, shapeColumn);
          }
          shapeColumn++;
        }
        shapeRow++;
      }
      if (downScore > 0) {
        return sideScore + downScore;
      }
      return 0;
    };

    /*
      function getDownTouchingScore:
          Get the Down Touching Score for a block. For each floor or other block
          below the block, add one point to the score.
      @param globalMatrix - the global Tetris matrix.
      @param row - the row value of the current block in the globalMatrix.
      @param column - the column value of the current block in the globalMatirx.
      @param shape - the Shape of the current domain value to score.
      @param shapeRow - the row value of the current block in the shape.
      @param shapeColumn - the column value of the current block in the shape.
      @return score - the total touching score for this block.
    */


    TetrisAI.prototype.getDownTouchingScore = function(globalMatrix, row, column, shape, shapeRow, shapeColumn) {
      var blockUnder, score;
      score = 0;
      if (row < 21) {
        blockUnder = globalMatrix[row + 1][column];
        if (shape[shapeRow + 1] !== void 0 && shape[shapeRow + 1][shapeColumn] !== shape[shapeRow][shapeColumn] && blockUnder > 0) {
          score += 3;
        } else if (shape[shapeRow + 1] === void 0 && blockUnder > 0) {
          score += 3;
        }
        if (blockUnder === -2) {
          score += 5;
        }
      }
      return score;
    };

    /*
      function getSideTouchingScore:
          Get the Side Touching Score for a block. For each wall or other block
          below the block, add one point to the score.
      @param globalMatrix - the global Tetris matrix.
      @param row - the row value of the current block in the globalMatrix.
      @param column - the column value of the current block in the globalMatirx.
      @param shape - the Shape of the current domain value to score.
      @param shapeRow - the row value of the current block in the shape.
      @param shapeColumn - the column value of the current block in the shape.
      @return score - the total touching score for this block.
    */


    TetrisAI.prototype.getSideTouchingScore = function(globalMatrix, row, column, shape, shapeRow, shapeColumn) {
      var blockLeft, blockRight, score;
      score = 0;
      if (row < 21) {
        if (column < 11 && column > 0) {
          blockLeft = globalMatrix[row][column - 1];
          if (shape[shapeRow][shapeColumn - 1] !== shape[shapeRow][shapeColumn]) {
            if (blockLeft > 0) {
              score += 3;
            }
          }
          if (blockLeft === -3) {
            score += 2.5;
          }
          blockRight = globalMatrix[row][column + 1];
          if (shape[shapeRow][shapeColumn + 1] !== shape[shapeRow][shapeColumn]) {
            if (blockRight > 0) {
              score += 3;
            }
          }
          if (blockRight === -3) {
            score += 2.5;
          }
        }
      }
      return score;
    };

    TetrisAI.prototype.checkLoss = function() {
      var y, _i;
      for (y = _i = 0; _i <= 11; y = ++_i) {
        if (this.Matrix[0][y] > 0) {
          clearInterval(window.GameClock);
          return true;
        }
      }
      return false;
    };

    TetrisAI.prototype.addDomainValue = function(tetromino, domainValue, matrix) {
      var constraintFit, valX, valY, x, y, _ref;
      constraintFit = this.checkGivenDomainValue(domainValue, matrix);
      if (constraintFit === true) {
        _ref = domainValue.matrix;
        for (x in _ref) {
          if (!__hasProp.call(_ref, x)) continue;
          valX = _ref[x];
          if (x >= 0) {
            for (y in valX) {
              if (!__hasProp.call(valX, y)) continue;
              valY = valX[y];
              if (y >= 0 && valY > 0) {
                matrix[x][y] = valY;
              }
            }
          }
        }
      }
      return constraintFit;
    };

    TetrisAI.prototype.checkGivenDomainValue = function(domainValue, matrix) {
      var row, shapeColumn, shapeRow, valX, valY, x, y, _i, _ref, _ref1, _ref2;
      shapeRow = 0;
      _ref = domainValue.matrix;
      for (x in _ref) {
        if (!__hasProp.call(_ref, x)) continue;
        valX = _ref[x];
        shapeColumn = 0;
        for (y in valX) {
          if (!__hasProp.call(valX, y)) continue;
          valY = valX[y];
          if (valY === domainValue.Tetrimino.Colour && domainValue.Shape[shapeRow][shapeColumn] === 1) {
            if (matrix[x][y] !== 0) {
              return false;
            }
          }
          shapeColumn++;
        }
        shapeRow++;
      }
      shapeRow = 0;
      _ref1 = domainValue.matrix;
      for (x in _ref1) {
        if (!__hasProp.call(_ref1, x)) continue;
        valX = _ref1[x];
        shapeColumn = 0;
        for (y in valX) {
          if (!__hasProp.call(valX, y)) continue;
          valY = valX[y];
          if (valY === domainValue.Tetrimino.Colour && domainValue.Shape[shapeRow][shapeColumn] === 1) {
            for (row = _i = _ref2 = parseInt(x); _ref2 <= 2 ? _i < 2 : _i > 2; row = _ref2 <= 2 ? ++_i : --_i) {
              if (matrix[row][y] !== 0) {
                return false;
              }
            }
          }
          shapeColumn++;
        }
        shapeRow++;
      }
      return true;
    };

    TetrisAI.prototype.score = function(linesCleared) {
      switch (linesCleared) {
        case 1:
          this.Points += 40 * (this.Level + 1);
          this.Lines += 1;
          this.TotalLines += 1;
          break;
        case 2:
          this.Points += 100 * (this.Level + 1);
          this.Lines += 2;
          this.TotalLines += 2;
          break;
        case 3:
          this.Points += 300 * (this.Level + 1);
          this.Lines += 3;
          this.TotalLines += 3;
          break;
        case 4:
          this.Points += 1200 * (this.Level + 1);
          this.Lines += 4;
          this.TotalLines += 4;
      }
      if (this.Lines > 10) {
        this.Lines = this.Lines % 10;
        if (this.Level < 10) {
          this.Level++;
        }
      }
      return linesCleared;
    };

    TetrisAI.prototype.copyMatrix = function(matrix) {
      var copy, i, _i, _ref;
      copy = [];
      for (i = _i = 0, _ref = matrix.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        copy[i] = matrix[i].slice(0);
      }
      return copy;
    };

    TetrisAI.prototype.draw = function(tetris) {
      var value, x, y, _i, _j;
      CONTEXT.clearRect(0, 0, CANVAS.width, CANVAS.height);
      CONTEXT.fillStyle = 'rgba(0, 0, 0, 0.3)';
      CONTEXT.fillRect(0, 0, CELL_SIZE * 10, CELL_SIZE * 20);
      for (x = _i = 0; _i < 10; x = ++_i) {
        for (y = _j = 0; _j < 20; y = ++_j) {
          value = this.Matrix[y + 1][x + 1];
          if (value !== 0 && value !== 8 && value !== 9 && value !== (-2) && value !== (-3)) {
            CONTEXT.fillStyle = colours[value];
            CONTEXT.fillRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
          }
        }
      }
      CONTEXT.font = 'bold 30px Ostrich';
      CONTEXT.fillStyle = 'rgb(255,255,119)';
      CONTEXT.fillText('Total Moves:', 424, 140);
      CONTEXT.fillText('Lines Cleared:', 424, 175);
      CONTEXT.fillText('Total Score:', 424, 210);
      CONTEXT.fillStyle = 'rgb(255,255,255)';
      CONTEXT.fillText(this.MoveCount, 574, 140);
      CONTEXT.fillText(this.TotalLines, 574, 175);
      return CONTEXT.fillText(this.Points, 574, 210);
    };

    return TetrisAI;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Tetris = Tetris;

  TetriminoBag = (function() {
    var fillBag;

    function TetriminoBag() {
      this._ = {
        bag: fillBag()
      };
    }

    fillBag = function() {
      return [new I(1, 1, 0, 2, 1), new J(2, 1, 0, 1, 1), new L(3, 1, 0, 1, 1), new O(4, 0, 0, 1, 0), new S(5, 1, 0, 1, 1), new T(6, 1, 0, 1, 1), new Z(7, 1, 0, 1, 1)];
    };

    TetriminoBag.prototype.getNext = function() {
      if (!(this._.bag != null) || this._.bag.length === 0) {
        this._.bag = fillBag();
      }
      return (this._.bag.splice(Math.floor(Math.random() * this._.bag.length), 1))[0];
    };

    return TetriminoBag;

  })();

  Tetrimino = (function() {

    function Tetrimino(Colour, Pivot, Rotation, PlusDiff, MinusDiff) {
      this.Colour = Colour;
      this.Pivot = Pivot;
      this.Rotation = Rotation;
      this.PlusDiff = PlusDiff;
      this.MinusDiff = MinusDiff;
    }

    Tetrimino.prototype.getDomain = function(matrix) {
      var boundaryColumn, boundaryRow, column, columnKeys, domainValue, localBoundaries, rotation, row, rowAbove, rowKeys, shape, shapeColumn, shapeRow, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.Domain = [];
      for (rotation = _i = 0, _ref = this.Shape.length; 0 <= _ref ? _i < _ref : _i > _ref; rotation = 0 <= _ref ? ++_i : --_i) {
        shape = this.Shape[rotation];
        this.Rotation = rotation;
        for (row = _j = 20, _ref1 = TetrisGame.getHighestRow(); 20 <= _ref1 ? _j <= _ref1 : _j >= _ref1; row = 20 <= _ref1 ? ++_j : --_j) {
          for (column = _k = 1; _k <= 10; column = ++_k) {
            localBoundaries = {};
            rowKeys = [];
            columnKeys = [];
            for (boundaryRow = _l = _ref2 = row - this.MinusDiff, _ref3 = row + this.PlusDiff; _ref2 <= _ref3 ? _l <= _ref3 : _l >= _ref3; boundaryRow = _ref2 <= _ref3 ? ++_l : --_l) {
              if (boundaryRow > -1 && boundaryRow < (21 + this.PlusDiff)) {
                rowKeys.push(boundaryRow);
                for (boundaryColumn = _m = _ref4 = column - this.MinusDiff, _ref5 = column + this.PlusDiff; _ref4 <= _ref5 ? _m <= _ref5 : _m >= _ref5; boundaryColumn = _ref4 <= _ref5 ? ++_m : --_m) {
                  if (boundaryColumn > -1 && boundaryColumn < (11 + this.PlusDiff)) {
                    columnKeys.push(boundaryColumn);
                    if (localBoundaries[boundaryRow] === void 0) {
                      localBoundaries[boundaryRow] = {};
                    }
                    if (matrix[boundaryRow] === void 0 || matrix[boundaryRow][boundaryColumn] === void 0) {
                      if (localBoundaries[boundaryRow][boundaryColumn] === void 0) {
                        localBoundaries[boundaryRow][boundaryColumn] = {};
                      }
                      localBoundaries[boundaryRow][boundaryColumn] = -2;
                    } else {
                      localBoundaries[boundaryRow][boundaryColumn] = matrix[boundaryRow][boundaryColumn];
                    }
                  }
                }
              }
            }
            rowKeys = _.uniq(rowKeys).sort(function(a, b) {
              return a - b;
            });
            columnKeys = _.uniq(columnKeys).sort(function(a, b) {
              return a - b;
            });
            try {
              shapeRow = 0;
              for (boundaryRow = _n = _ref6 = rowKeys[0], _ref7 = rowKeys[rowKeys.length - 1]; _ref6 <= _ref7 ? _n <= _ref7 : _n >= _ref7; boundaryRow = _ref6 <= _ref7 ? ++_n : --_n) {
                shapeColumn = 0;
                for (boundaryColumn = _o = _ref8 = columnKeys[0], _ref9 = columnKeys[columnKeys.length - 1]; _ref8 <= _ref9 ? _o <= _ref9 : _o >= _ref9; boundaryColumn = _ref8 <= _ref9 ? ++_o : --_o) {
                  if (shape[shapeRow][shapeColumn] === 1) {
                    if (localBoundaries[boundaryRow][boundaryColumn] === -2 || localBoundaries[boundaryRow][boundaryColumn] === -3) {
                      throw new Error("Part of tetromino outside of Matrix");
                    } else if (localBoundaries[boundaryRow][boundaryColumn] === 0) {
                      localBoundaries[boundaryRow][boundaryColumn] += shape[shapeRow][shapeColumn] * this.Colour;
                    } else {
                      throw new Error("Location already assigned");
                    }
                  }
                  shapeColumn++;
                }
                shapeRow++;
              }
              shapeColumn = 0;
              for (boundaryColumn = _p = _ref10 = columnKeys[0], _ref11 = columnKeys[columnKeys.length - 1]; _ref10 <= _ref11 ? _p <= _ref11 : _p >= _ref11; boundaryColumn = _ref10 <= _ref11 ? ++_p : --_p) {
                shapeRow = 0;
                for (boundaryRow = _q = _ref12 = rowKeys[0], _ref13 = rowKeys[rowKeys.length - 1]; _ref12 <= _ref13 ? _q <= _ref13 : _q >= _ref13; boundaryRow = _ref12 <= _ref13 ? ++_q : --_q) {
                  if (localBoundaries[boundaryRow][boundaryColumn] === this.Colour && shape[shapeRow][shapeColumn] === 1) {
                    for (rowAbove = _r = boundaryRow; boundaryRow <= 2 ? _r < 2 : _r > 2; rowAbove = boundaryRow <= 2 ? ++_r : --_r) {
                      if (matrix[rowAbove][boundaryColumn] !== 0) {
                        throw new Error("No path to location");
                      }
                    }
                    break;
                  }
                  shapeRow++;
                }
                shapeColumn++;
              }
              domainValue = {
                matrix: localBoundaries,
                score: this.getScore(shape, localBoundaries, matrix),
                Shape: shape,
                Tetrimino: this
              };
              if (domainValue.score > 0) {
                this.Domain.push(domainValue);
              }
            } catch (_error) {}
          }
        }
      }
      return this.Domain.sort(function(a, b) {
        return b.score - a.score;
      });
    };

    /*
      function getScore:
          For each block in the shape, sum the touching scores of the blocks.
      @param shape - the Shape of the current domain value to score.
      @param localMatrix - the local area in which the shape will be placed.
      @param globalMatrix - the global Tetris matrix.
      @return score - the total score for this shape.
    */


    Tetrimino.prototype.getScore = function(shape, localMatrix, globalMatrix) {
      var column, columnValue, downScore, row, rowValues, shapeColumn, shapeRow, sideScore;
      downScore = 0;
      sideScore = 0;
      shapeRow = 0;
      for (row in localMatrix) {
        if (!__hasProp.call(localMatrix, row)) continue;
        rowValues = localMatrix[row];
        shapeColumn = 0;
        for (column in rowValues) {
          if (!__hasProp.call(rowValues, column)) continue;
          columnValue = rowValues[column];
          if (columnValue === this.Colour && shape[shapeRow][shapeColumn] === 1) {
            downScore += this.getDownTouchingScore(globalMatrix, parseInt(row), parseInt(column), shape, shapeRow, shapeColumn);
            sideScore += this.getSideTouchingScore(globalMatrix, parseInt(row), parseInt(column), shape, shapeRow, shapeColumn);
          }
          shapeColumn++;
        }
        shapeRow++;
      }
      if (downScore > 0) {
        return sideScore + downScore;
      }
      return 0;
    };

    /*
      function getDownTouchingScore:
          Get the Down Touching Score for a block. For each floor or other block
          below the block, add one point to the score.
      @param globalMatrix - the global Tetris matrix.
      @param row - the row value of the current block in the globalMatrix.
      @param column - the column value of the current block in the globalMatirx.
      @param shape - the Shape of the current domain value to score.
      @param shapeRow - the row value of the current block in the shape.
      @param shapeColumn - the column value of the current block in the shape.
      @return score - the total touching score for this block.
    */


    Tetrimino.prototype.getDownTouchingScore = function(globalMatrix, row, column, shape, shapeRow, shapeColumn) {
      var blockUnder, score;
      score = 0;
      if (row < 21) {
        blockUnder = globalMatrix[row + 1][column];
        if (shape[shapeRow + 1] !== void 0 && shape[shapeRow + 1][shapeColumn] !== shape[shapeRow][shapeColumn] && blockUnder > 0) {
          score += 3;
        } else if (shape[shapeRow + 1] === void 0 && blockUnder > 0) {
          score += 3;
        }
        if (blockUnder === -2) {
          score += 5;
        }
      }
      return score;
    };

    /*
      function getSideTouchingScore:
          Get the Side Touching Score for a block. For each wall or other block
          below the block, add one point to the score.
      @param globalMatrix - the global Tetris matrix.
      @param row - the row value of the current block in the globalMatrix.
      @param column - the column value of the current block in the globalMatirx.
      @param shape - the Shape of the current domain value to score.
      @param shapeRow - the row value of the current block in the shape.
      @param shapeColumn - the column value of the current block in the shape.
      @return score - the total touching score for this block.
    */


    Tetrimino.prototype.getSideTouchingScore = function(globalMatrix, row, column, shape, shapeRow, shapeColumn) {
      var blockLeft, blockRight, score;
      score = 0;
      if (row < 21) {
        if (column < 11 && column > 0) {
          blockLeft = globalMatrix[row][column - 1];
          if (shape[shapeRow][shapeColumn - 1] !== shape[shapeRow][shapeColumn]) {
            if (blockLeft > 0) {
              score += 3;
            }
          }
          if (blockLeft === -3) {
            score += 2.5;
          }
          blockRight = globalMatrix[row][column + 1];
          if (shape[shapeRow][shapeColumn + 1] !== shape[shapeRow][shapeColumn]) {
            if (blockRight > 0) {
              score += 3;
            }
          }
          if (blockRight === -3) {
            score += 2.5;
          }
        }
      }
      return score;
    };

    return Tetrimino;

  })();

  I = (function(_super) {

    __extends(I, _super);

    function I(c, p, r, pd, md) {
      I.__super__.constructor.call(this, c, p, r, pd, md);
      this.Shape = [[[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]];
    }

    return I;

  })(Tetrimino);

  J = (function(_super) {

    __extends(J, _super);

    function J(c, p, r, pd, md) {
      J.__super__.constructor.call(this, c, p, r, pd, md);
      this.Shape = [[[0, 0, 0], [1, 1, 1], [0, 0, 1]], [[0, 1, 0], [0, 1, 0], [1, 1, 0]], [[1, 0, 0], [1, 1, 1], [0, 0, 0]], [[0, 1, 1], [0, 1, 0], [0, 1, 0]]];
    }

    return J;

  })(Tetrimino);

  L = (function(_super) {

    __extends(L, _super);

    function L(c, p, r, pd, md) {
      L.__super__.constructor.call(this, c, p, r, pd, md);
      this.Shape = [[[0, 0, 0], [1, 1, 1], [1, 0, 0]], [[1, 1, 0], [0, 1, 0], [0, 1, 0]], [[0, 0, 1], [1, 1, 1], [0, 0, 0]], [[0, 1, 0], [0, 1, 0], [0, 1, 1]]];
    }

    return L;

  })(Tetrimino);

  O = (function(_super) {

    __extends(O, _super);

    function O(c, p, r, pd, md) {
      O.__super__.constructor.call(this, c, p, r, pd, md);
      this.Shape = [[[1, 1], [1, 1]]];
    }

    return O;

  })(Tetrimino);

  S = (function(_super) {

    __extends(S, _super);

    function S(c, p, r, pd, md) {
      S.__super__.constructor.call(this, c, p, r, pd, md);
      this.Shape = [[[0, 0, 0], [0, 1, 1], [1, 1, 0]], [[1, 0, 0], [1, 1, 0], [0, 1, 0]], [[0, 1, 1], [1, 1, 0], [0, 0, 0]], [[0, 1, 0], [0, 1, 1], [0, 0, 1]]];
    }

    return S;

  })(Tetrimino);

  T = (function(_super) {

    __extends(T, _super);

    function T(c, p, r, pd, md) {
      T.__super__.constructor.call(this, c, p, r, pd, md);
      this.Shape = [[[0, 0, 0], [1, 1, 1], [0, 1, 0]], [[0, 1, 0], [1, 1, 0], [0, 1, 0]], [[0, 1, 0], [1, 1, 1], [0, 0, 0]], [[0, 1, 0], [0, 1, 1], [0, 1, 0]]];
    }

    return T;

  })(Tetrimino);

  Z = (function(_super) {

    __extends(Z, _super);

    function Z(c, p, r, pd, md) {
      Z.__super__.constructor.call(this, c, p, r, pd, md);
      this.Shape = [[[0, 0, 0], [1, 1, 0], [0, 1, 1]], [[0, 1, 0], [1, 1, 0], [1, 0, 0]], [[1, 1, 0], [0, 1, 1], [0, 0, 0]], [[0, 0, 1], [0, 1, 1], [0, 1, 0]]];
    }

    return Z;

  })(Tetrimino);

  this.Tetromino = Tetrimino;

}).call(this);
