// Generated by CoffeeScript 1.6.3
(function() {
  var Animate, Thingie,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Animate = (function() {
    var DEFAULT_MATRIX, animate, cssMatrixCompose, cssMatrixDecompose, getMatrixFromProperties, getStyle, name, setting, settings, update, _animating, _getOptions, _keys, _transformMappings;
    settings = {
      POSITION: {
        X: function(value) {
          return {
            property: 'position.x',
            value: value,
            absolute: true
          };
        },
        Y: function(value) {
          return {
            property: 'position.y',
            value: value,
            absolute: true
          };
        },
        Z: function(value) {
          return {
            property: 'position.z',
            value: value,
            absolute: false,
            nSteps: 8
          };
        }
      },
      SCALE: {
        X: function(value) {
          return {
            property: 'scale.x',
            value: value,
            absolute: false,
            nSteps: 8
          };
        },
        Y: function(value) {
          return {
            property: 'scale.y',
            value: value,
            absolute: false,
            nSteps: 8
          };
        },
        Z: function(value) {
          return {
            property: 'scale.z',
            value: value,
            absolute: false,
            nSteps: 8
          };
        }
      }
    };
    DEFAULT_MATRIX = 'matrix(1, 0, 0, 1, 0, 0)';
    getStyle = function(element) {
      if (element.currentStyle) {
        return element.currentStyle;
      } else if (window.getComputedStyle) {
        return document.defaultView.getComputedStyle(element, null);
      }
    };
    window.transform = (function() {
      var spelling, spellings, style, _i, _len;
      style = getStyle(document.documentElement);
      spellings = ['transform', '-moz-transform', 'moz-transform', 'mozTransfrom', 'MozTransform', '-webkit-transform', 'webkit-transform', 'webkitTransform', 'WebkitTransform', '-o-transform', 'o-transform', 'oTransform', 'OTransform', '-ms-transform', 'ms-transform', 'msTransform', 'MsTransform'];
      for (_i = 0, _len = spellings.length; _i < _len; _i++) {
        spelling = spellings[_i];
        if ({}.hasOwnProperty.call(style, spelling) || (style[spelling] != null)) {
          return spelling;
        }
      }
    })();
    getMatrixFromProperties = function(properties) {
      var newMatrix, scaleX, scaleY, scaleZ, style, translateX, translateY, translateZ, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      _ref = /translateX\((-?\d+)px\)/.exec(properties) || ['', 0], style = _ref[0], translateX = _ref[1];
      _ref1 = /translateY\((-?\d+)px\)/.exec(properties) || ['', 0], style = _ref1[0], translateY = _ref1[1];
      _ref2 = /translateZ\((-?\d+)px\)/.exec(properties) || ['', 0], style = _ref2[0], translateZ = _ref2[1];
      _ref3 = /scaleX\((-?\d+)\)/.exec(properties) || ['', 1], style = _ref3[0], scaleX = _ref3[1];
      _ref4 = /scaleY\((-?\d+)\)/.exec(properties) || ['', 1], style = _ref4[0], scaleY = _ref4[1];
      _ref5 = /scaleZ\((-?\d+)\)/.exec(properties) || ['', 1], style = _ref5[0], scaleZ = _ref5[1];
      newMatrix = [scaleX, 0, 0, 0, 0, scaleY, 0, 0, 0, 0, scaleZ, 0, translateX, translateY, translateZ, 1];
      return "matrix3d(" + (newMatrix.join(', ')) + ")";
    };
    cssMatrixDecompose = function(element, property) {
      var matrix, values;
      matrix = getStyle(element).getPropertyValue(window.transform);
      if (matrix === 'none') {
        matrix = element.style[window.transform];
      }
      if (matrix === 'none' || matrix === '') {
        matrix = DEFAULT_MATRIX;
      }
      if (matrix.indexOf('matrix') === -1) {
        matrix = getMatrixFromProperties(matrix);
      }
      values = matrix.split(/\(|\)/)[1].split(', ');
      switch (property) {
        case 'translateX':
          if (values.length === 6) {
            return values[4];
          } else {
            return values[12];
          }
          break;
        case 'translateY':
          if (values.length === 6) {
            return values[5];
          } else {
            return values[13];
          }
          break;
        case 'translateZ':
          if (values.length === 6) {
            return 0;
          } else {
            return values[14];
          }
      }
    };
    cssMatrixCompose = function(object, property, value) {
      var css, newMatrix, values;
      css = getStyle(object).getPropertyValue(window.transform);
      css = css === 'none' ? DEFAULT_MATRIX : css;
      values = css.split(/\(|\)/)[1].split(', ');
      newMatrix = [values[0], values[1], 0, 0, values[2], values[3], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      switch (property) {
        case 'translateX':
          newMatrix[12] = value;
          break;
        case 'translateY':
          newMatrix[13] = value;
          break;
        case 'translateZ':
          newMatrix[14] = value;
      }
      return "matrix3d(" + (newMatrix.join(', ')) + ")";
    };
    update = function() {
      var animation, property, steps, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = _animating.length; _i < _len; _i++) {
        animation = _animating[_i];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (property in animation) {
            if (!__hasProp.call(animation, property)) continue;
            steps = animation[property];
            if (property !== 'callback' && property !== 'object') {
              if (steps.length > 0) {
                switch (property) {
                  case 'position.x':
                    _results1.push(animation.object.position.x = steps.shift());
                    break;
                  case 'position.y':
                    _results1.push(animation.object.position.y = steps.shift());
                    break;
                  case 'position.z':
                    _results1.push(animation.object.position.z = steps.shift());
                    break;
                  case 'scale.x':
                    _results1.push(animation.object.scale.x = steps.shift());
                    break;
                  case 'scale.y':
                    _results1.push(animation.object.scale.y = steps.shift());
                    break;
                  case 'scale.z':
                    _results1.push(animation.object.scale.z = steps.shift());
                    break;
                  case 'translateX' || 'translateY' || 'translateZ':
                    _results1.push(animation.object.style[window.transform] = cssMatrixCompose(animation.object, property, steps.shift()));
                    break;
                  default:
                    _results1.push(void 0);
                }
              } else {
                if (animation.callback != null) {
                  animation.callback();
                  animation.callback = null;
                  delete animation.callback;
                  animation[property] = null;
                  _results1.push(delete animation[property]);
                } else {
                  _results1.push(void 0);
                }
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    _animating = [];
    _keys = [];
    _getOptions = function(options) {
      if (!options.property) {
        throw Error('ANIMATION OPTIONS ERROR: Animation property must be defined.');
      }
      if (!options.value) {
        throw Error('ANIMATION OPTIONS ERROR: Animation value must be defined.');
      }
      if (options.nSteps == null) {
        options.nSteps = 30;
      }
      return options.absolute != null ? options.absolute : options.absolute = false;
    };
    _transformMappings = {
      'position.x': 'translateX',
      'position.y': 'translateY',
      'position.z': 'translateZ'
    };
    animate = function(object, options, callback) {
      var current, endValue, key, objects, previousAnimations, property, steps, _base, _i, _j, _len, _ref, _ref1, _ref2, _results, _results1;
      _getOptions(options);
      objects = object instanceof NodeList || object instanceof Array ? object : [object];
      _results = [];
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i];
        property = options.property;
        if (object instanceof HTMLElement) {
          property = _transformMappings[property];
        }
        current = options.value;
        switch (property) {
          case 'position.x':
            current = object.position.x;
            break;
          case 'position.y':
            current = object.position.y;
            break;
          case 'position.z':
            current = object.position.z;
            break;
          case 'scale.x':
            current = object.scale.x;
            break;
          case 'scale.y':
            current = object.scale.y;
            break;
          case 'scale.z':
            current = object.scale.z;
            break;
          case 'translateX' || 'translateY' || 'translateZ':
            current = +cssMatrixDecompose(object, property);
        }
        key = _keys.indexOf(object);
        if (key === -1) {
          _keys.push(object);
          key = _keys.indexOf(object);
        }
        if (((_ref = _animating[key]) != null ? (_ref1 = _ref[property]) != null ? _ref1.length : void 0 : void 0) > 0) {
          previousAnimations = _animating[key][property];
          current = previousAnimations[previousAnimations.length - 1];
        }
        endValue = options.absolute ? current + options.value : options.value;
        steps = (function() {
          _results1 = [];
          for (var _j = 0, _ref2 = options.nSteps; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; 0 <= _ref2 ? _j++ : _j--){ _results1.push(_j); }
          return _results1;
        }).apply(this).map(function(i) {
          return current + (-i * (current - endValue) / (options.nSteps - 1));
        });
        if (_animating[key] == null) {
          _animating[key] = {
            object: object
          };
        }
        if (callback != null) {
          _animating[key].callback = callback;
          callback = null;
        }
        if ((_base = _animating[key])[property] == null) {
          _base[property] = [];
        }
        _results.push(_animating[key][property] = _animating[key][property].concat(steps));
      }
      return _results;
    };
    animate.update = update;
    for (name in settings) {
      if (!__hasProp.call(settings, name)) continue;
      setting = settings[name];
      animate[name] = setting;
    }
    return animate;
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Animate = Animate;

  (typeof exports !== "undefined" && exports !== null ? exports : this).Blocks = (function() {
    var BLOCK_Y_SPACING, Block, BlockGroup, GAP, GEOMETRY, HALF_GAP, HALF_SIZE, HD_SCREEN_HEIGHT, HD_SCREEN_WIDTH, IN_POSITION, NUMBER_OF_BLOCK_PER_ROW, OFFSET, OUT_POSITION, SIZE, init, makeProjectTitle;
    HD_SCREEN_WIDTH = 1920;
    HD_SCREEN_HEIGHT = 1080;
    NUMBER_OF_BLOCK_PER_ROW = 50;
    BLOCK_Y_SPACING = HD_SCREEN_WIDTH / NUMBER_OF_BLOCK_PER_ROW;
    SIZE = BLOCK_Y_SPACING * 0.7;
    HALF_SIZE = SIZE / 2;
    IN_POSITION = SIZE * -0.5;
    OUT_POSITION = SIZE * -0.5 + 50;
    GAP = BLOCK_Y_SPACING * 0.3;
    HALF_GAP = GAP / 2;
    OFFSET = BLOCK_Y_SPACING;
    GEOMETRY = new THREE.CubeGeometry(SIZE, SIZE, SIZE);
    BlockGroup = (function() {
      function BlockGroup(blocks, elements, offDirection) {
        this.blocks = blocks;
        this.elements = elements;
        this.offDirection = offDirection;
        if (this.elements != null) {
          if (!this.elements.length) {
            this.elements = [this.elements];
          }
          if (this.elements instanceof NodeList || this.elements instanceof jQuery) {
            this.elements = Array.prototype.slice.call(this.elements);
          }
        }
        this.move(this.offDirection, 3000);
      }

      BlockGroup.prototype.get = function(prop) {
        return _.map(this.blocks, function(block) {
          return block[prop];
        });
      };

      BlockGroup.prototype.on = function(eventType, handler) {
        var objects;
        objects = this.get('object');
        Events.on(eventType, objects, handler);
        return this;
      };

      BlockGroup.prototype.off = function(eventType, handler) {
        var objects;
        objects = this.get('object');
        Events.off(eventType, objects, handler);
        return this;
      };

      BlockGroup.prototype.animate = function(options, callback) {
        var objects;
        objects = this.get('object');
        Animate(objects, options, callback);
        if (this.elements) {
          Animate(this.elements, options);
        }
        return this;
      };

      BlockGroup.prototype.move = function(direction, amount, css) {
        var block, _i, _len, _ref, _transformMappings;
        if (css == null) {
          css = {};
        }
        if (direction === 'LEFT' || direction === 'RIGHT') {
          amount *= direction === 'LEFT' ? -1 : 1;
          direction = 'x';
        }
        if (direction === 'UP' || direction === 'DOWN') {
          amount *= direction === 'DOWN' ? -1 : 1;
          direction = 'y';
        }
        _ref = this.blocks;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          block = _ref[_i];
          block.object.position[direction] += amount;
        }
        if (this.elements) {
          if (direction === 'y') {
            amount *= -1;
          }
          _transformMappings = {
            'position.x': 'translateX',
            'position.y': 'translateY',
            'position.z': 'translateZ'
          };
          css[window.transform] = "" + _transformMappings['position.' + direction] + "(" + amount + "px)";
          $(this.elements).css(css);
        }
        return this;
      };

      return BlockGroup;

    })();
    Block = (function() {
      function Block(x, y, width, height, colour, content) {
        var letter, letterGeometry;
        this.x = x;
        this.y = y;
        this.width = width != null ? width : 1;
        this.height = height != null ? height : 1;
        this.colour = colour != null ? colour : Colours.blue;
        this.content = content != null ? content : null;
        this.material = Materials.phong(this.colour);
        this.object = new THREE.Mesh(GEOMETRY, this.material);
        this.object.position.x = this.x * OFFSET + (this.width * HALF_SIZE) + (this.width - 1) * HALF_GAP;
        this.object.position.y = HD_SCREEN_HEIGHT - this.y * OFFSET - (this.height * HALF_SIZE) - (this.height - 1) * HALF_GAP;
        this.object.position.z = IN_POSITION;
        this.object.scale.x = (SIZE * this.width + GAP * (this.width - 1)) / SIZE;
        this.object.scale.y = (SIZE * this.height + GAP * (this.height - 1)) / SIZE;
        this.object.castShadow = this.object.recieveShadow = true;
        if (this.content != null) {
          letterGeometry = new THREE.TextGeometry(this.content, {
            font: 'college',
            size: SIZE * 0.9
          });
          letter = new THREE.Mesh(letterGeometry, Materials.lambert(Colours.white));
          letter.position = new THREE.Vector3(-SIZE * (this.content === 'I' ? 0.18 : 0.3), -SIZE * 0.45, -SIZE * 0.35);
          letter.scale.z = 0.6;
          this.object.add(letter);
        }
        Main.scene.add(this.object);
      }

      return Block;

    })();
    init = function(callback) {
      var global;
      global = typeof exports !== "undefined" && exports !== null ? exports : window;
      return $.getJSON('blocks.json', function(result) {
        var blockGroup, blockGroups, blocks, colour, content, elementEvents, event, events, handlerName, height, name, offDirection, page, requires, selector, width, x, y, _base, _base1;
        for (page in result) {
          if (!__hasProp.call(result, page)) continue;
          blockGroups = result[page];
          if ((_base = global.Blocks)[page] == null) {
            _base[page] = {};
          }
          for (name in blockGroups) {
            if (!__hasProp.call(blockGroups, name)) continue;
            blockGroup = blockGroups[name];
            if ((_base1 = global.Blocks[page])[name] == null) {
              _base1[name] = {};
            }
            x = blockGroup.x, y = blockGroup.y, blocks = blockGroup.blocks, width = blockGroup.width, height = blockGroup.height, colour = blockGroup.colour, content = blockGroup.content;
            requires = blockGroup.requires, offDirection = blockGroup.offDirection, selector = blockGroup.selector, events = blockGroup.events, elementEvents = blockGroup.elementEvents;
            blocks = _.map(blocks, function(block) {
              var blockColour, blockContent, blockHeight, blockRequires, blockWidth, blockX, blockY, requiresOk, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
              blockX = (_ref = block.x) != null ? _ref : x;
              blockY = (_ref1 = block.y) != null ? _ref1 : y;
              blockWidth = (_ref2 = block.width) != null ? _ref2 : width;
              blockHeight = (_ref3 = block.height) != null ? _ref3 : height;
              blockColour = (_ref4 = block.colour) != null ? _ref4 : colour;
              blockContent = (_ref5 = block.content) != null ? _ref5 : content;
              blockRequires = (_ref6 = block.requires) != null ? _ref6 : requires;
              requiresOk = true;
              if (blockRequires != null) {
                _.each(blockRequires.split(' '), function(require) {
                  return requiresOk = requiresOk && Modernizr[require];
                });
              }
              if (requiresOk) {
                return new Block(blockX, blockY, blockWidth, blockHeight, Colours[blockColour], blockContent);
              }
            });
            if (blocks.length > 0) {
              blockGroup = new BlockGroup(blocks, $(selector), offDirection);
              for (event in events) {
                if (!__hasProp.call(events, event)) continue;
                handlerName = events[event];
                if (handlerName === 'menuOver') {
                  blockGroup.on(event, UI.events[handlerName](blockGroup, name));
                } else {
                  blockGroup.on(event, UI.events[handlerName]);
                }
              }
              for (event in elementEvents) {
                if (!__hasProp.call(elementEvents, event)) continue;
                handlerName = elementEvents[event];
                $(blockGroup.elements).on(event, UI.events[handlerName]);
              }
              global.Blocks[page][name] = blockGroup;
            }
          }
        }
        return callback();
      });
    };
    makeProjectTitle = function(name) {
      var titleBlocks;
      titleBlocks = (function() {
        var BLOCK_X;
        BLOCK_X = _.map(name, function(content, i) {
          return 2 + i * 2;
        });
        return _.map(BLOCK_X, function(x, i) {
          return new Block(x, 2, 2, 2, Colours.blue, name[i]);
        });
      })();
      return new BlockGroup(titleBlocks, null, 'RIGHT');
    };
    return {
      init: init,
      makeProjectTitle: makeProjectTitle,
      OUT_POSITION: OUT_POSITION,
      IN_POSITION: IN_POSITION
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Blog = (function() {
    var init;
    init = function() {
      return $.get('blog/1000GoodIntentions.html', (function(result) {
        $('#content-blog').html(result);
        $('#blog a').attr('target', '_blank');
        $('#cover-blog img').attr('src', '../blog/covers/LA DISPUTE - WILDLIFE.png');
        return $('#info-blog a').text('LA DISPUTE: Wildlife').attr('href', 'https://itunes.apple.com/nz/album/wildlife/id463651346');
      }));
    };
    return {
      init: init
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Colours = (function() {
    return {
      "default": 0xDDDDFF,
      blue: 0x444499,
      white: 0xFFFFFF,
      background: {
        day: 0x000000,
        night: 0x060708
      },
      light: {
        day: 0xDDDDDD,
        night: 0xFFFFFF
      }
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).CV = (function() {
    var init;
    init = function() {
      return $.get('cv/cv.html', (function(result) {
        $('#content-cv').html(result);
        return $('#cv a').attr('target', '_blank');
      }));
    };
    return {
      init: init
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).DeviceOrientation = (function() {
    var DEVICE_ORIENTATION, X_AXIS, Z_AXIS, init, piOver540, rotateAroundWorldAxis, _lastBeta, _lastGamma;
    DEVICE_ORIENTATION = 'deviceorientation';
    X_AXIS = new THREE.Vector3(1, 0, 0);
    Z_AXIS = new THREE.Vector3(0, 0, 1);
    piOver540 = Math.PI / 540;
    _lastBeta = _lastGamma = null;
    rotateAroundWorldAxis = function(object, axis, radians) {
      var rotationMatrix;
      rotationMatrix = new THREE.Matrix4();
      rotationMatrix.makeRotationAxis(axis, radians);
      if (axis !== X_AXIS) {
        rotationMatrix.multiply(object.matrix);
      }
      object.matrix = rotationMatrix;
      return object.rotation.setFromRotationMatrix(object.matrix);
    };
    init = function() {
      if (Modernizr.deviceorientation) {
        return window.addEventListener(DEVICE_ORIENTATION, function(event, xTilt, zTilt) {
          if (xTilt == null) {
            xTilt = 0;
          }
          if (zTilt == null) {
            zTilt = 0;
          }
          return _.each(Blocks.common.HEADER.blocks, function(block) {
            if (Math.abs(_lastBeta - event.beta) > 5) {
              xTilt = -event.beta * piOver540;
            }
            if (Math.abs(_lastGamma - event.gamma) > 5) {
              zTilt = event.gamma * piOver540;
            }
            rotateAroundWorldAxis(block.object, X_AXIS, xTilt);
            return rotateAroundWorldAxis(block.object, Z_AXIS, zTilt);
          });
        });
      }
    };
    return {
      init: init
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Events = (function() {
    var addEventListener, get, init, removeEventListener, update, _activeEvents, _camera, _click, _eventMappings, _getWidthAndHeight, _height, _intersected, _mousePixelsX, _mousePixelsY, _mouseX, _mouseY, _mousedown, _mouseup, _objects, _previousIntersected, _previousMouseX, _previousMouseY, _previousObjects, _projector, _runEvents, _scene, _width;
    _projector = new THREE.Projector();
    _scene = null;
    _camera = null;
    _previousIntersected = [];
    _previousObjects = [];
    _intersected = [];
    _objects = [];
    _previousMouseX = _previousMouseY = 0;
    _width = _height = null;
    _mouseX = _mouseY = 0;
    _mousePixelsX = _mousePixelsY = 0;
    _activeEvents = {};
    _eventMappings = {};
    _getWidthAndHeight = function(container) {
      if (container.height() >= container.width() * 9 / 16) {
        _height = container.height();
        _width = _height * 16 / 9;
        return $('main').css({
          'overflow-x': 'scroll',
          'overflow-y': 'hidden'
        });
      } else {
        _width = container.width();
        return _height = _width * 9 / 16;
      }
    };
    _getWidthAndHeight($(window));
    _mousedown = false;
    _mouseup = false;
    _click = false;
    $(document.body).mousemove(function(e) {
      _mouseX = 2 * ((e.clientX + $('main').scrollLeft()) / _width) - 1;
      _mouseY = -2 * ((e.clientY + $(document).scrollTop()) / _height) + 1;
      _mousePixelsX = e.clientX;
      return _mousePixelsY = e.clientY;
    });
    $(document.body).click(function(e) {
      return _click = true;
    });
    $(document.body).mousedown(function(e) {
      _mousedown = true;
      return _mouseup = false;
    });
    $(document.body).mouseup(function(e) {
      _mousedown = false;
      return _mouseup = true;
    });
    $(window).resize(function(e) {
      return _getWidthAndHeight($(window));
    });
    _runEvents = function() {
      return _.each(_activeEvents, function(objects, event) {
        return _.each(objects, function(object) {
          var _ref;
          if (((_ref = _eventMappings[event]) != null ? _ref[object.id] : void 0) != null) {
            return _.each(_eventMappings[event][object.id], function(handler) {
              return handler(_objects);
            });
          }
        });
      });
    };
    init = function(scene, camera) {
      _scene = scene;
      return _camera = camera;
    };
    get = {
      mouse: function() {
        return [_mouseX, _mouseY];
      },
      mousePixels: function() {
        return [_mousePixelsX, _mousePixelsY];
      },
      screenSize: function() {
        return [_width, _height];
      }
    };
    update = function() {
      var intersection, previousIntersection, raycaster, vecOrigin, vecTarget, _ref;
      _activeEvents = {};
      _previousIntersected = _intersected;
      vecOrigin = new THREE.Vector3(_mouseX, _mouseY, -1);
      vecTarget = new THREE.Vector3(_mouseX, _mouseY, 1);
      _projector.unprojectVector(vecOrigin, _camera);
      _projector.unprojectVector(vecTarget, _camera);
      vecTarget.sub(vecOrigin).normalize();
      raycaster = new THREE.Raycaster(vecOrigin, vecTarget);
      _intersected = raycaster.intersectObjects(_scene.children);
      _objects = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = _intersected.length; _i < _len; _i++) {
          intersection = _intersected[_i];
          _results.push(intersection.object);
        }
        return _results;
      })();
      _previousObjects = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = _previousIntersected.length; _i < _len; _i++) {
          previousIntersection = _previousIntersected[_i];
          _results.push(previousIntersection.object);
        }
        return _results;
      })();
      _activeEvents.mouseover = _.difference(_objects, _previousObjects);
      _activeEvents.mouseout = _.difference(_previousObjects, _objects);
      if (_previousMouseX !== _mouseX && _previousMouseY !== _mouseY) {
        _activeEvents.mousemove = _.intersection(_objects, _previousObjects);
      }
      if (_objects.length > 0) {
        if (_mousedown) {
          _activeEvents.mousedown = _objects;
          _mousedown = false;
        }
        if (_mouseup) {
          _activeEvents.mouseup = _objects;
          _mouseup = false;
        }
        if (_click) {
          _activeEvents.click = _objects;
          _click = false;
        }
      }
      _ref = [_mouseX, _mouseY], _previousMouseX = _ref[0], _previousMouseY = _ref[1];
      return _runEvents();
    };
    addEventListener = function(event, objects, handler) {
      var arrObjects;
      arrObjects = !_.isArray(objects) ? [objects] : objects;
      _.each(arrObjects, function(object) {
        var _base, _name;
        if (_eventMappings[event] == null) {
          _eventMappings[event] = {};
        }
        if ((_base = _eventMappings[event])[_name = object.id] == null) {
          _base[_name] = [];
        }
        return _eventMappings[event][object.id].push(handler);
      });
      return objects;
    };
    removeEventListener = function(event, objects, handler) {
      var arrObjects, hasEvents, index, object, objectEvents, _i, _len, _ref;
      arrObjects = !_.isArray(objects) ? [objects] : objects;
      for (_i = 0, _len = arrObjects.length; _i < _len; _i++) {
        object = arrObjects[_i];
        hasEvents = ((_ref = _eventMappings[event]) != null ? _ref[object.id] : void 0) != null;
        objectEvents = _eventMappings[event][object.id];
        if (objectEvents) {
          if ((hasEvents != null) && (index = objectEvents.indexOf(handler)) > -1) {
            objectEvents.splice(index, 1);
          } else if ((hasEvents != null) && (handler == null)) {
            _eventMappings[event][object.id] = [];
          }
        }
      }
      return objects;
    };
    return {
      init: init,
      get: get,
      update: update,
      addEventListener: addEventListener,
      on: addEventListener,
      removeEventListener: removeEventListener,
      off: removeEventListener
    };
  })();

  $(function() {
    var addDomEvents, _ref;
    if (Modernizr.webgl) {
      addDomEvents = function() {
        document.body.addEventListener('mousemove', UI.events.mousemove);
        document.body.addEventListener(fullscreenchange, UI.events.windowResize);
        $(window).on('resize', UI.events.windowResize);
        return $(window).trigger('resize');
      };
      _ref = Rendering.init(), Main.scene = _ref[0], Main.camera = _ref[1];
      Events.init(Main.scene, Main.camera);
      return Blocks.init(function() {
        Blog.init();
        CV.init();
        DeviceOrientation.init();
        return Scenes.init(function() {
          Routing.init();
          Thingie.init();
          Twitter.init();
          addDomEvents();
          return Main.update();
        });
      });
    }
  });

  (typeof exports !== "undefined" && exports !== null ? exports : this).Main = (function() {
    var toggleDebug, update;
    toggleDebug = function() {
      Main.debug = !Main.debug;
      return Rendering.toggleDebug();
    };
    update = function() {
      Animate.update();
      Events.update();
      Rendering.update();
      Thingie.update();
      Projects.update();
      return requestAnimationFrame(update);
    };
    return {
      debug: false,
      toggleDebug: toggleDebug,
      update: update
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Materials = (function() {
    var _make;
    _make = function(type, colour) {
      var options;
      options = {
        color: colour,
        shading: THREE.SmoothShading,
        overdraw: true,
        wireframe: Main.debug
      };
      return new THREE["Mesh" + type + "Material"](options);
    };
    return {
      phong: function(colour) {
        return _make('Phong', colour);
      },
      lambert: function(colour) {
        return _make('Lambert', colour);
      }
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Projects = (function() {
    var init, kill, update, _currentProject;
    _currentProject = null;
    init = function(project) {
      return $.getScript("/javascript/" + project + ".js").done(function() {
        Rendering.initProject();
        _currentProject = project;
        return window[_currentProject].init($('#project-content'));
      });
    };
    update = function() {
      if (_currentProject) {
        return window[_currentProject].update();
      }
    };
    kill = function() {
      if (_currentProject) {
        window[_currentProject].kill();
        _currentProject = null;
        return Rendering.killProject();
      }
    };
    return {
      init: init,
      update: update,
      kill: kill
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Rendering = (function() {
    var ASPECT_RATIO, FAR_Z, FIELD_OF_VIEW, NEAR_Z, SIX_AM, SIX_PM, init, initProject, killProject, setLightTarget, setRendererSize, toggleDebug, update, _camera, _initCamera, _initLights, _initShadow, _lights, _makeLight, _nighttime, _project, _renderer, _scene;
    FIELD_OF_VIEW = 70;
    ASPECT_RATIO = 16 / 9;
    NEAR_Z = 0.01;
    FAR_Z = 800;
    SIX_AM = 6;
    SIX_PM = 18;
    _scene = new THREE.Scene();
    _renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    _camera = new THREE.PerspectiveCamera(FIELD_OF_VIEW, ASPECT_RATIO, NEAR_Z, FAR_Z);
    _lights = [];
    _nighttime = false;
    _project = false;
    _initShadow = function() {
      _renderer.shadowMapEnabled = true;
      _renderer.shadowCameraNear = NEAR_Z;
      _renderer.shadowCameraFar = FAR_Z;
      _renderer.shadowCameraFov = FIELD_OF_VIEW;
      _renderer.shadowMapDarkness = 1;
      _renderer.shadowMapWidth = 256;
      return _renderer.shadowMapHeight = 256;
    };
    _initCamera = function() {
      _camera.position = new THREE.Vector3(960, 540, 772);
      return _camera.lookAt(new THREE.Vector3(960, 540, 0));
    };
    _makeLight = function(colour, position) {
      var light;
      light = _nighttime ? new THREE.SpotLight(colour, 2.5) : new THREE.DirectionalLight(colour);
      light.position = position;
      light.target.position = new THREE.Vector3(960, 540, 10);
      light.castShadow = true;
      light.shadowCameraVisible = Main.debug;
      _lights.push(light);
      return _scene.add(light);
    };
    _initLights = function() {
      _nighttime = new Date().getHours() < SIX_AM || new Date().getHours() > SIX_PM;
      if (_nighttime) {
        _renderer.setClearColor(Colours.background.night, 1);
        _makeLight(Colours.light.night, new THREE.Vector3(0, 1080, 250));
        return _makeLight(Colours.light.night, new THREE.Vector3(1920, 1080, 250));
      } else {
        _renderer.setClearColor(Colours.background.day, 0);
        _makeLight(Colours.light.day, new THREE.Vector3(-200, 1080, 700));
        return _makeLight(Colours.light.day, new THREE.Vector3(2120, 1080, 700));
      }
    };
    init = function() {
      _initShadow();
      _initCamera();
      _initLights();
      $('main').append(_renderer.domElement);
      setRendererSize(Events.get.screenSize());
      return [_scene, _camera];
    };
    setLightTarget = function(position) {
      if (!_project) {
        return _.each(_lights, function(light) {
          return light.target.position = position;
        });
      }
    };
    setRendererSize = function(screenSize) {
      return _renderer.setSize.apply(_renderer, screenSize);
    };
    toggleDebug = function() {
      return _.each(_scene.children, function(child) {
        if (child instanceof THREE.DirectionalLight) {
          child.shadowCameraVisible = Main.debug;
        } else if (child.material != null) {
          child.material.wireframe = Main.debug;
        }
        return _.each(child.children, function(letter) {
          if (letter.material != null) {
            return letter.material.wireframe = Main.debug;
          }
        });
      });
    };
    update = function() {
      if (!_project) {
        return _renderer.render(_scene, _camera);
      }
    };
    initProject = function() {
      _.each(_lights, function(light) {
        return light.target.position = new THREE.Vector3(960, 540, 0);
      });
      return _project = true;
    };
    killProject = function() {
      return _project = false;
    };
    return {
      init: init,
      initProject: initProject,
      killProject: killProject,
      setLightTarget: setLightTarget,
      setRendererSize: setRendererSize,
      toggleDebug: toggleDebug,
      update: update
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Routing = (function() {
    var back, go, init, _currentSection, _router, _setCurrentSection;
    _router = new Router();
    _currentSection = 'home';
    _setCurrentSection = function(newSection) {
      _currentSection = newSection;
      document.title = "Craig Spence | " + (_currentSection.toUpperCase());
      return $('section').removeClass('current').filter("#" + _currentSection).addClass('current');
    };
    init = function() {
      var key, param, params, redirect, value, _i, _len, _ref;
      _router.route('/*path', function() {
        return Projects.kill();
      });
      _router.route('/home', function() {
        return Scenes.change('home', function() {
          return _setCurrentSection('home');
        });
      });
      _router.route('/projects', function() {
        return Scenes.change('projects', function() {
          return _setCurrentSection('projects');
        });
      });
      _router.route('/projects/:project', function(project) {
        Scenes['projects/project'].blockGroups[4] = Blocks.makeProjectTitle(project);
        return Scenes.change('projects/project', function() {
          _setCurrentSection('project');
          return Projects.init(project);
        });
      });
      _router.route('/social', function() {
        return Scenes.change('social', function() {
          return _setCurrentSection('social');
        });
      });
      _router.route('/blog', function() {
        return Scenes.change('blog', function() {
          return _setCurrentSection('blog');
        });
      });
      _router.route('/cv', function() {
        return Scenes.change('cv', function() {
          return _setCurrentSection('cv');
        });
      });
      params = window.location.search.substring(1).split('&');
      for (_i = 0, _len = params.length; _i < _len; _i++) {
        param = params[_i];
        _ref = param.split('='), key = _ref[0], value = _ref[1];
        if (key === 'redirect') {
          redirect = decodeURIComponent(value);
        }
      }
      if (redirect == null) {
        redirect = 'home';
      }
      if (redirect.substr(-1) === '/') {
        redirect = redirect.substr(0, redirect.length - 1);
      }
      if (redirect.substr(0, 1) === '/') {
        redirect = redirect.substr(1);
      }
      return Routing.go(redirect, true);
    };
    go = function(name, replace) {
      if (replace == null) {
        replace = false;
      }
      return _router.navigate("/" + (name.toLowerCase()), true, replace);
    };
    back = function() {
      if (_currentSection === 'projects' || _currentSection === 'social' || _currentSection === 'blog' || _currentSection === 'cv') {
        _router.navigate('/home');
      }
      if (_currentSection === 'project') {
        return _router.navigate('/projects');
      }
    };
    return {
      init: init,
      go: go,
      back: back
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Scenes = (function() {
    var change, init, _getBlocks, _getOffAnimation, _getOnAnimation, _on;
    _on = [];
    _getOnAnimation = function(blockGroup) {
      switch (blockGroup.offDirection) {
        case 'LEFT':
          return Animate.POSITION.X(3000);
        case 'RIGHT':
          return Animate.POSITION.X(-3000);
        case 'UP':
          return Animate.POSITION.Y(-3000);
        case 'DOWN':
          return Animate.POSITION.Y(3000);
      }
    };
    _getOffAnimation = function(blockGroup) {
      switch (blockGroup.offDirection) {
        case 'LEFT':
          return Animate.POSITION.X(-3000);
        case 'RIGHT':
          return Animate.POSITION.X(3000);
        case 'UP':
          return Animate.POSITION.Y(3000);
        case 'DOWN':
          return Animate.POSITION.Y(-3000);
      }
    };
    _getBlocks = function(name) {
      var blockGroup, firstDot, n, scene, _ref, _ref1, _results;
      firstDot = name.indexOf('.');
      _ref = [name.substr(0, firstDot), name.substr(firstDot + 1)], scene = _ref[0], name = _ref[1];
      if (name && scene) {
        return [Blocks[scene][name]];
      } else {
        _ref1 = Blocks[name];
        _results = [];
        for (n in _ref1) {
          if (!__hasProp.call(_ref1, n)) continue;
          blockGroup = _ref1[n];
          _results.push(blockGroup);
        }
        return _results;
      }
    };
    init = function(callback) {
      return $.getJSON('scenes.json', function(result) {
        var blockName, blockNames, name, _i, _len;
        for (name in result) {
          if (!__hasProp.call(result, name)) continue;
          blockNames = result[name];
          if (!_.isFunction(blockNames)) {
            if (Scenes[name] == null) {
              Scenes[name] = {
                blockGroups: []
              };
            }
            for (_i = 0, _len = blockNames.length; _i < _len; _i++) {
              blockName = blockNames[_i];
              Scenes[name].blockGroups = Scenes[name].blockGroups.concat(_getBlocks(blockName));
            }
          }
        }
        return callback();
      });
    };
    change = function(scene, callback, newOn) {
      if (newOn == null) {
        newOn = [];
      }
      if (_on.length === 0) {
        callback();
      }
      _.each(_on, function(blockGroup) {
        var animation;
        if (__indexOf.call(Scenes[scene].blockGroups, blockGroup) < 0) {
          animation = _getOffAnimation(blockGroup);
          blockGroup.animate(animation, callback);
          return callback = null;
        } else {
          return newOn.push(blockGroup);
        }
      });
      _.each(Scenes[scene].blockGroups, function(blockGroup) {
        var animation;
        if (__indexOf.call(newOn, blockGroup) < 0) {
          animation = _getOnAnimation(blockGroup);
          blockGroup.animate(animation);
          return newOn.push(blockGroup);
        }
      });
      return _on = newOn;
    };
    return {
      init: init,
      change: change
    };
  })();

  (function() {
    window.requestAnimFrame = (function() {
      return requestAnimationFrame || webkitRequestAnimationFrame || mozRequestAnimationFrame || oRequestAnimationFrame || msRequestAnimationFrame || function(callback) {
        return setTimeout(callback, 1000 / 60);
      };
    })();
    window.cancelAnimFrame = (function() {
      return cancelAnimationFrame || webkitCancelAnimationFrame || mozCancelAnimationFrame || oCancelAnimationFrame || msCancelAnimationFrame;
    })();
    HTMLElement.prototype.requestFullscreen = (function() {
      if (HTMLElement.prototype.requestFullscreen) {
        return HTMLElement.prototype.requestFullscreen;
      } else if (HTMLElement.prototype.mozRequestFullScreen) {
        return HTMLElement.prototype.mozRequestFullScreen;
      } else if (HTMLElement.prototype.webkitRequestFullscreen) {
        return function() {
          return this.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        };
      } else if (HTMLElement.prototype.webkitRequestFullScreen) {
        return function() {
          return this.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
        };
      }
    })();
    document.exitFullscreen = (function() {
      return document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullScreen || document.webkitCancelFullScreen;
    })();
    document.isFullScreen = function() {
      return (document.fullScreenElement != null) || (document.mozFullScreenElement != null) || document.mozIsFullScreen || (document.webkitFullScreenElement != null) || document.webkitIsFullScreen;
    };
    return window.fullscreenchange = (function() {
      var body;
      body = document.body;
      if (body.onfullscreenchange != null) {
        return 'fullscreenchange';
      } else if (body.onmozfullscreenchange != null) {
        return 'mozfullscreenchange';
      } else if (body.onwebkitfullscreenchange != null) {
        return 'webkitfullscreenchange';
      } else {
        return null;
      }
    })();
  })();

  Thingie = (function() {
    var REQUEST_ANIMATION_FRAME_FPS, frame, thingie, thingies, _blocks, _getRandomColour;
    thingies = [];
    _blocks = null;
    REQUEST_ANIMATION_FRAME_FPS = 60;
    frame = 0;
    _getRandomColour = function(base) {
      var b, g, r;
      r = Math.floor(Math.random() * (255 - base) + base);
      g = Math.floor(Math.random() * (255 - base) + base);
      b = Math.floor(Math.random() * (255 - base) + base);
      return parseInt(r.toString(16) + g.toString(16) + b.toString(16), 16);
    };
    if (Modernizr.webgl) {
      thingies.push((function() {
        var framesPerUpdate;
        framesPerUpdate = REQUEST_ANIMATION_FRAME_FPS / 2;
        return {
          init: function() {
            return _blocks = Blocks.home.CONTENT.blocks;
          },
          update: function() {
            var block, _i, _len;
            if (frame % framesPerUpdate === 0) {
              for (_i = 0, _len = _blocks.length; _i < _len; _i++) {
                block = _blocks[_i];
                block.object.material.color.setHex(_getRandomColour(155));
              }
            }
            return frame += 1;
          }
        };
      })());
      if (Modernizr.geolocation) {
        thingies.push((function() {
          var _getMapPosition, _locationBlock, _world;
          _world = [430, 431, 432, 433, 435, 477, 479, 481, 482, 483, 490, 491, 492, 494, 525, 526, 527, 528, 529, 530, 531, 533, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 577, 578, 579, 580, 581, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 628, 629, 630, 635, 637, 638, 639, 640, 641, 642, 643, 644, 645, 678, 679, 680, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 729, 735, 736, 737, 738, 739, 741, 742, 780, 781, 785, 786, 787, 788, 791, 792, 831, 832, 836, 837, 838, 842, 843, 845, 880, 881, 882, 883, 887, 888, 894, 895, 931, 932, 937, 938, 943, 944, 945, 981, 982, 987, 993, 995, 997, 1031, 1047, 1081];
          _locationBlock = null;
          _getMapPosition = function(position) {
            var LAT_OFFSET, LAT_SPAN, LAT_STEPS, LONG_OFFSET, LONG_SPAN, LONG_STEPS, block, blockIndex, latDivision, latDivisions, latIndex, latitude, longDivision, longDivisions, longIndex, longitude, roundedLat, roundedLong, _i, _j, _k, _len, _ref, _results, _results1, _results2;
            _ref = position.coords, latitude = _ref.latitude, longitude = _ref.longitude;
            LAT_SPAN = 150;
            LAT_OFFSET = -60;
            LAT_STEPS = 14;
            latDivisions = (function() {
              _results = [];
              for (var _i = LAT_STEPS; LAT_STEPS <= 1 ? _i <= 1 : _i >= 1; LAT_STEPS <= 1 ? _i++ : _i--){ _results.push(_i); }
              return _results;
            }).apply(this).map(function(i) {
              return (i * (LAT_SPAN / LAT_STEPS)) + LAT_OFFSET;
            });
            LONG_SPAN = 360;
            LONG_OFFSET = -180;
            LONG_STEPS = 24;
            longDivisions = (function() {
              _results1 = [];
              for (var _j = 1; 1 <= LONG_STEPS ? _j <= LONG_STEPS : _j >= LONG_STEPS; 1 <= LONG_STEPS ? _j++ : _j--){ _results1.push(_j); }
              return _results1;
            }).apply(this).map(function(i) {
              return (i * (LONG_SPAN / LONG_STEPS)) + LONG_OFFSET;
            });
            if (latitude >= LAT_OFFSET) {
              latDivision = LAT_SPAN / LAT_STEPS;
              roundedLat = Math.ceil((latitude - LAT_OFFSET) / latDivision) * latDivision + LAT_OFFSET;
              longDivision = LONG_SPAN / LONG_STEPS;
              roundedLong = Math.ceil((longitude - LONG_OFFSET) / longDivision) * longDivision + LONG_OFFSET;
              latIndex = latDivisions.indexOf(roundedLat);
              longIndex = longDivisions.indexOf(roundedLong);
              blockIndex = 424 + longIndex + (50 * latIndex);
              _results2 = [];
              for (_k = 0, _len = _blocks.length; _k < _len; _k++) {
                block = _blocks[_k];
                if ((block.x + (block.y * 50)) === blockIndex) {
                  _locationBlock = block;
                  _results2.push(block.object.material.color.setHex(0x44ff44));
                } else {
                  _results2.push(void 0);
                }
              }
              return _results2;
            }
          };
          return {
            init: function() {
              var block, _i, _len, _ref, _results;
              _blocks = Blocks.home.CONTENT.blocks;
              setTimeout((function() {
                return navigator.geolocation.getCurrentPosition(_getMapPosition);
              }), 1000);
              _results = [];
              for (_i = 0, _len = _blocks.length; _i < _len; _i++) {
                block = _blocks[_i];
                if (_ref = block.x + (block.y * 50), __indexOf.call(_world, _ref) >= 0) {
                  _results.push(block.object.material.color.setHex(0x4444ff));
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            },
            update: function() {}
          };
        })());
      }
      thingies.push((function() {
        var _createFood, _direction, _drawFood, _drawGameOver, _drawSnake, _eatFood, _food, _foodColour, _framesPerUpdate, _getNextSpot, _go, _moveSnake, _nextDirection, _reduceFrames, _reset, _score, _snake;
        _snake = _food = _foodColour = _go = _direction = _score = _nextDirection = null;
        _framesPerUpdate = 20;
        _reduceFrames = false;
        _eatFood = function(nextSpot) {
          _score += 251 - _framesPerUpdate;
          if (_framesPerUpdate > 3) {
            _reduceFrames = true;
          }
          return _snake.push(nextSpot);
        };
        _createFood = function() {
          var _results;
          _results = [];
          while (__indexOf.call(_snake, _food) >= 0) {
            _results.push(_food = (Math.floor(Math.random() * 24) + 24) + (Math.floor(Math.random() * 14) * 50) + 400);
          }
          return _results;
        };
        _getNextSpot = function(spot) {
          var _i, _j, _ref, _ref1, _results, _results1;
          if (_direction === 'RIGHT') {
            if ((_ref = spot % 100) === 47 || _ref === 97) {
              return spot - 23;
            } else {
              return spot + 1;
            }
          } else if (_direction === 'LEFT') {
            if ((_ref1 = spot % 100) === 24 || _ref1 === 74) {
              return spot + 23;
            } else {
              return spot - 1;
            }
          } else if (_direction === 'UP') {
            if (__indexOf.call((function() {
              _results = [];
              for (_i = 424; _i < 448; _i++){ _results.push(_i); }
              return _results;
            }).apply(this), spot) >= 0) {
              return spot + 650;
            } else {
              return spot - 50;
            }
          } else if (_direction === 'DOWN') {
            if (__indexOf.call((function() {
              _results1 = [];
              for (_j = 1074; _j < 1098; _j++){ _results1.push(_j); }
              return _results1;
            }).apply(this), spot) >= 0) {
              return spot - 650;
            } else {
              return spot + 50;
            }
          }
        };
        _moveSnake = function() {
          var nextSpot;
          _direction = _nextDirection;
          nextSpot = _getNextSpot(_snake[_snake.length - 1]);
          if (__indexOf.call(_snake, nextSpot) < 0) {
            if (nextSpot === _food) {
              _eatFood(nextSpot);
              _createFood();
            } else {
              _snake = _snake.slice(1);
              _snake.push(nextSpot);
            }
            return true;
          } else {
            return false;
          }
        };
        _drawSnake = function(block) {
          var _ref;
          if (_ref = block.x + (block.y * 50), __indexOf.call(_snake, _ref) >= 0) {
            if (_snake.indexOf(block.x + (block.y * 50)) === _snake.length - 1) {
              return block.object.material.color.setHex(0x4444ff);
            } else {
              return block.object.material.color.setHex(0x222222);
            }
          }
        };
        _drawFood = function(block) {
          if ((block.x + (block.y * 50)) === _food) {
            return block.object.material.color.setHex(_foodColour);
          }
        };
        _reset = function() {
          var a, block, e, k, letters, n, s, _i, _j, _len, _len1, _ref, _results;
          _snake = [875, 876, 877, 878, 879];
          _food = 885;
          _foodColour = 0x44bb44;
          _framesPerUpdate = 20;
          _direction = 'RIGHT';
          _nextDirection = 'RIGHT';
          _score = 0;
          s = [475, 476, 477, 525, 575, 576, 577, 627, 675, 676, 677];
          n = [479, 482, 529, 530, 532, 579, 581, 582, 629, 632, 679, 682];
          a = [484, 485, 486, 534, 536, 584, 585, 586, 634, 636, 684, 686];
          k = [488, 491, 538, 540, 588, 589, 638, 640, 688, 691];
          e = [493, 494, 495, 543, 593, 594, 643, 693, 694, 695];
          letters = [].concat(s, n, a, k, e);
          for (_i = 0, _len = _blocks.length; _i < _len; _i++) {
            block = _blocks[_i];
            block.object.material.color.setHex(0xddddff);
            if (_ref = block.x + (block.y * 50), __indexOf.call(letters, _ref) >= 0) {
              block.object.material.color.setHex(0x444499);
            }
          }
          _results = [];
          for (_j = 0, _len1 = _blocks.length; _j < _len1; _j++) {
            block = _blocks[_j];
            _drawSnake(block);
            _results.push(_drawFood(block));
          }
          return _results;
        };
        _drawGameOver = function() {
          var a, block, e, e2, g, letters, m, o, r, v, _i, _len, _ref, _results;
          g = [475, 476, 477, 525, 575, 577, 625, 627, 675, 676, 677];
          a = [479, 480, 481, 529, 531, 579, 580, 581, 629, 631, 679, 681];
          m = [483, 487, 533, 534, 536, 537, 583, 585, 587, 633, 637, 683, 687];
          e = [489, 490, 491, 539, 589, 590, 639, 689, 690, 691];
          o = [775, 776, 777, 825, 827, 875, 877, 925, 927, 975, 976, 977];
          v = [779, 781, 829, 831, 879, 881, 929, 931, 980];
          e2 = [783, 784, 785, 833, 883, 884, 933, 983, 984, 985];
          r = [787, 788, 837, 839, 887, 888, 937, 939, 987, 989];
          letters = [].concat(g, a, m, e, o, v, e2, r);
          _results = [];
          for (_i = 0, _len = _blocks.length; _i < _len; _i++) {
            block = _blocks[_i];
            block.object.material.color.setHex(0xddddff);
            if (_ref = block.x + (block.y * 50), __indexOf.call(letters, _ref) >= 0) {
              _results.push(block.object.material.color.setHex(0x444499));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        return {
          init: function() {
            _blocks = Blocks.home.CONTENT.blocks;
            return _reset();
          },
          update: function() {
            var block, _i, _len;
            if (_go) {
              if (frame % _framesPerUpdate === 0) {
                if (_moveSnake()) {
                  for (_i = 0, _len = _blocks.length; _i < _len; _i++) {
                    block = _blocks[_i];
                    block.object.material.color.setHex(0xddddff);
                    _drawSnake(block);
                    _drawFood(block);
                  }
                  if (_reduceFrames) {
                    _framesPerUpdate -= 1;
                    _reduceFrames = false;
                  }
                } else {
                  _drawGameOver();
                  _go = false;
                  setTimeout((function() {
                    alert("YOUR SCORE: " + _score + "!");
                    return _reset();
                  }), 40);
                }
              }
              return frame += 1;
            }
          },
          eventHandlers: {
            keydown: function(e) {
              var _ref;
              _go = true;
              switch (e.keyCode) {
                case 37:
                  if (_direction === 'UP' || _direction === 'DOWN') {
                    _nextDirection = 'LEFT';
                  }
                  break;
                case 38:
                  if (_direction === 'LEFT' || _direction === 'RIGHT') {
                    _nextDirection = 'UP';
                  }
                  break;
                case 39:
                  if (_direction === 'UP' || _direction === 'DOWN') {
                    _nextDirection = 'RIGHT';
                  }
                  break;
                case 40:
                  if (_direction === 'LEFT' || _direction === 'RIGHT') {
                    _nextDirection = 'DOWN';
                  }
              }
              if (_ref = e.keyCode, __indexOf.call([37, 38, 39, 40], _ref) >= 0) {
                e.preventDefault();
                return false;
              } else {
                return true;
              }
            }
          }
        };
      })());
    }
    thingie = thingies[Math.floor(Math.random() * thingies.length)];
    if (thingie) {
      return (function() {
        var event, handler, _ref;
        _ref = thingie.eventHandlers;
        for (event in _ref) {
          if (!__hasProp.call(_ref, event)) continue;
          handler = _ref[event];
          $(document.body).on(event, handler);
        }
        return {
          init: thingie.init,
          update: thingie.update
        };
      })();
    }
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Thingie = Thingie;

  (typeof exports !== "undefined" && exports !== null ? exports : this).Twitter = (function() {
    var MONTHS, TWEET_PATH, _$twitter, _count, _displayNextTweet, _formatDate, _handleTweets, _tweets;
    MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    TWEET_PATH = 'http://phenomnomnominal.herokuapp.com/getTweets.json?callback=?';
    _$twitter = $('#twitter span');
    _tweets = _count = null;
    _formatDate = function(date) {
      var dateStr, day, hour, meridian, mins, month, year;
      date = new Date(date);
      month = date.getMonth();
      day = date.getDate();
      year = date.getFullYear();
      hour = date.getHours();
      mins = date.getMinutes();
      meridian = hour > 11 ? 'PM' : 'AM';
      hour = hour % 12;
      hour = hour === 0 ? 12 : hour;
      mins = mins < 10 ? '0' + mins : mins;
      return dateStr = "" + MONTHS[month] + " " + day + ", " + year + " at " + hour + ":" + mins + " " + meridian;
    };
    _handleTweets = function(response) {
      _tweets = response.data;
      _displayNextTweet();
      return $(window).resize();
    };
    _displayNextTweet = function() {
      clearInterval(scroll);
      _count = _count === (_tweets.length - 1) || _count === null ? 0 : _count + 1;
      _$twitter.html("<em>></em>" + _tweets[_count].text + " - (" + (_formatDate(_tweets[_count].created_at)) + ")");
      return setTimeout((function() {
        var scroll;
        return scroll = setInterval((function() {
          _$twitter.html("<em>></em>" + (_$twitter.text().slice(3)));
          if (_$twitter.text().length < 3) {
            clearInterval(scroll);
            return _displayNextTweet();
          }
        }), 300);
      }), 1000);
    };
    return {
      init: function() {
        return $.getJSON(TWEET_PATH, _handleTweets);
      }
    };
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).UI = (function() {
    var events;
    events = {
      menuOver: function(blockGroup, name) {
        return function(intersected) {
          events.addPointer();
          blockGroup.animate(Animate.POSITION.Z(Blocks.OUT_POSITION));
          blockGroup.on('click', (function(name) {
            return function() {
              return Routing.go(name);
            };
          })(name));
          blockGroup.on('mouseout', events.menuOut(blockGroup, name));
          return blockGroup.off('mouseover');
        };
      },
      menuOut: function(blockGroup, name) {
        return function(intersected) {
          if (_.intersection(intersected, blockGroup.get('object')).length === 0) {
            events.removePointer();
            blockGroup.animate(Animate.POSITION.Z(Blocks.IN_POSITION));
            blockGroup.off('click');
            blockGroup.off('mouseout');
            return blockGroup.on('mouseover', events.menuOver(blockGroup, name));
          }
        };
      },
      addPointer: function() {
        return $(document.body).addClass('cursor');
      },
      removePointer: function() {
        return $(document.body).removeClass('cursor');
      },
      back: function() {
        return Routing.back();
      },
      initProject: function(e) {
        var projectId, projectName;
        projectId = $(e.target).closest('a').attr('id');
        projectName = projectId.substr(0, projectId.indexOf('-project'));
        return Routing.go("projects/" + projectName);
      },
      toggleFullscreen: function() {
        if (document.isFullScreen()) {
          return document.exitFullscreen();
        } else {
          return document.documentElement.requestFullscreen();
        }
      },
      toggleWireframe: function() {
        return Main.toggleDebug();
      },
      windowResize: function() {
        var height, screenSize, width;
        screenSize = Events.get.screenSize();
        Rendering.setRendererSize(screenSize);
        width = screenSize[0], height = screenSize[1];
        $('main').height(height);
        $('#wrapper').width(width).height(width);
        return $(document.body).css({
          'font-size': (width / 25) * 0.85
        });
      },
      mousemove: function() {
        var x, y, _ref;
        _ref = Events.get.mousePixels(), x = _ref[0], y = _ref[1];
        return Rendering.setLightTarget(new THREE.Vector3(x, 1080 - y, 10));
      }
    };
    return {
      events: events
    };
  })();

}).call(this);
