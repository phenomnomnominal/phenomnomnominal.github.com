// Generated by CoffeeScript 1.6.2
(function() {
  var Animate,
    __hasProp = {}.hasOwnProperty;

  Animate = (function() {
    var DEFAULT_MATRIX, animate, cssMatrixCompose, cssMatrixDecompose, getMatrixFromProperties, getStyle, name, setting, settings, update, _animating, _getOptions, _keys, _transformMappings;

    settings = {
      POSITION: {
        X: function(value) {
          return {
            property: 'position.x',
            value: value,
            absolute: true
          };
        },
        Y: function(value) {
          return {
            property: 'position.y',
            value: value,
            absolute: true
          };
        },
        Z: function(value) {
          return {
            property: 'position.z',
            value: value,
            absolute: false,
            nSteps: 8
          };
        }
      },
      SCALE: {
        X: function(value) {
          return {
            property: 'scale.x',
            value: value,
            absolute: false,
            nSteps: 8
          };
        },
        Y: function(value) {
          return {
            property: 'scale.y',
            value: value,
            absolute: false,
            nSteps: 8
          };
        },
        Z: function(value) {
          return {
            property: 'scale.z',
            value: value,
            absolute: false,
            nSteps: 8
          };
        }
      }
    };
    DEFAULT_MATRIX = 'matrix(1, 0, 0, 1, 0, 0)';
    getStyle = function(element) {
      if (element.currentStyle) {
        return element.currentStyle;
      } else if (window.getComputedStyle) {
        return document.defaultView.getComputedStyle(element, null);
      }
    };
    window.transform = (function() {
      var spelling, spellings, style, _i, _len;

      style = getStyle(document.documentElement);
      spellings = ['transform', '-moz-transform', 'moz-transform', 'mozTransfrom', 'MozTransform', '-webkit-transform', 'webkit-transform', 'webkitTransform', 'WebkitTransform', '-o-transform', 'o-transform', 'oTransform', 'OTransform', '-ms-transform', 'ms-transform', 'msTransform', 'MsTransform'];
      for (_i = 0, _len = spellings.length; _i < _len; _i++) {
        spelling = spellings[_i];
        if ({}.hasOwnProperty.call(style, spelling) || (style[spelling] != null)) {
          return spelling;
        }
      }
    })();
    getMatrixFromProperties = function(properties) {
      var newMatrix, scaleX, scaleY, scaleZ, style, translateX, translateY, translateZ, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

      _ref = /translateX\((-?\d+)px\)/.exec(properties) || ['', 0], style = _ref[0], translateX = _ref[1];
      _ref1 = /translateY\((-?\d+)px\)/.exec(properties) || ['', 0], style = _ref1[0], translateY = _ref1[1];
      _ref2 = /translateZ\((-?\d+)px\)/.exec(properties) || ['', 0], style = _ref2[0], translateZ = _ref2[1];
      _ref3 = /scaleX\((-?\d+)\)/.exec(properties) || ['', 1], style = _ref3[0], scaleX = _ref3[1];
      _ref4 = /scaleY\((-?\d+)\)/.exec(properties) || ['', 1], style = _ref4[0], scaleY = _ref4[1];
      _ref5 = /scaleZ\((-?\d+)\)/.exec(properties) || ['', 1], style = _ref5[0], scaleZ = _ref5[1];
      newMatrix = [scaleX, 0, 0, 0, 0, scaleY, 0, 0, 0, 0, scaleZ, 0, translateX, translateY, translateZ, 1];
      return "matrix3d(" + (newMatrix.join(', ')) + ")";
    };
    cssMatrixDecompose = function(element, property) {
      var matrix, values;

      matrix = getStyle(element).getPropertyValue(window.transform);
      if (matrix === 'none') {
        matrix = element.style[window.transform];
      }
      if (matrix === 'none' || matrix === '') {
        matrix = DEFAULT_MATRIX;
      }
      if (matrix.indexOf('matrix') === -1) {
        matrix = getMatrixFromProperties(matrix);
      }
      values = matrix.split(/\(|\)/)[1].split(', ');
      switch (property) {
        case 'translateX':
          if (values.length === 6) {
            return values[4];
          } else {
            return values[12];
          }
          break;
        case 'translateY':
          if (values.length === 6) {
            return values[5];
          } else {
            return values[13];
          }
          break;
        case 'translateZ':
          if (values.length === 6) {
            return 0;
          } else {
            return values[14];
          }
      }
    };
    cssMatrixCompose = function(object, property, value) {
      var css, newMatrix, values;

      css = getStyle(object).getPropertyValue(window.transform);
      css = css === 'none' ? DEFAULT_MATRIX : css;
      values = css.split(/\(|\)/)[1].split(', ');
      newMatrix = [values[0], values[1], 0, 0, values[2], values[3], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      switch (property) {
        case 'translateX':
          newMatrix[12] = value;
          break;
        case 'translateY':
          newMatrix[13] = value;
          break;
        case 'translateZ':
          newMatrix[14] = value;
      }
      return "matrix3d(" + (newMatrix.join(', ')) + ")";
    };
    update = function() {
      var animation, property, steps, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = _animating.length; _i < _len; _i++) {
        animation = _animating[_i];
        _results.push((function() {
          var _results1;

          _results1 = [];
          for (property in animation) {
            if (!__hasProp.call(animation, property)) continue;
            steps = animation[property];
            if (property !== 'callback' && property !== 'object') {
              if (steps.length > 0) {
                switch (property) {
                  case 'position.x':
                    _results1.push(animation.object.position.x = steps.shift());
                    break;
                  case 'position.y':
                    _results1.push(animation.object.position.y = steps.shift());
                    break;
                  case 'position.z':
                    _results1.push(animation.object.position.z = steps.shift());
                    break;
                  case 'scale.x':
                    _results1.push(animation.object.scale.x = steps.shift());
                    break;
                  case 'scale.y':
                    _results1.push(animation.object.scale.y = steps.shift());
                    break;
                  case 'scale.z':
                    _results1.push(animation.object.scale.z = steps.shift());
                    break;
                  case 'translateX' || 'translateY' || 'translateZ':
                    _results1.push(animation.object.style[window.transform] = cssMatrixCompose(animation.object, property, steps.shift()));
                    break;
                  default:
                    _results1.push(void 0);
                }
              } else {
                if (animation.callback != null) {
                  animation.callback();
                  animation.callback = null;
                  delete animation.callback;
                  animation[property] = null;
                  _results1.push(delete animation[property]);
                } else {
                  _results1.push(void 0);
                }
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    _animating = [];
    _keys = [];
    _getOptions = function(options) {
      var _ref, _ref1;

      if (!options.property) {
        throw Error('ANIMATION OPTIONS ERROR: Animation property must be defined.');
      }
      if (!options.value) {
        throw Error('ANIMATION OPTIONS ERROR: Animation value must be defined.');
      }
      if ((_ref = options.nSteps) == null) {
        options.nSteps = 30;
      }
      return (_ref1 = options.absolute) != null ? _ref1 : options.absolute = false;
    };
    _transformMappings = {
      'position.x': 'translateX',
      'position.y': 'translateY',
      'position.z': 'translateZ'
    };
    animate = function(object, options, callback) {
      var current, endValue, key, objects, previousAnimations, property, steps, _base, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _results, _results1;

      _getOptions(options);
      objects = object instanceof NodeList || object instanceof Array ? object : [object];
      _results = [];
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i];
        property = options.property;
        if (object instanceof HTMLElement) {
          property = _transformMappings[property];
        }
        current = options.value;
        switch (property) {
          case 'position.x':
            current = object.position.x;
            break;
          case 'position.y':
            current = object.position.y;
            break;
          case 'position.z':
            current = object.position.z;
            break;
          case 'scale.x':
            current = object.scale.x;
            break;
          case 'scale.y':
            current = object.scale.y;
            break;
          case 'scale.z':
            current = object.scale.z;
            break;
          case 'translateX' || 'translateY' || 'translateZ':
            current = +cssMatrixDecompose(object, property);
        }
        key = _keys.indexOf(object);
        if (key === -1) {
          _keys.push(object);
          key = _keys.indexOf(object);
        }
        if (((_ref = _animating[key]) != null ? (_ref1 = _ref[property]) != null ? _ref1.length : void 0 : void 0) > 0) {
          previousAnimations = _animating[key][property];
          current = previousAnimations[previousAnimations.length - 1];
        }
        endValue = options.absolute ? current + options.value : options.value;
        steps = (function() {
          _results1 = [];
          for (var _j = 0, _ref2 = options.nSteps; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; 0 <= _ref2 ? _j++ : _j--){ _results1.push(_j); }
          return _results1;
        }).apply(this).map(function(i) {
          return current + (-i * (current - endValue) / (options.nSteps - 1));
        });
        if ((_ref3 = _animating[key]) == null) {
          _animating[key] = {
            object: object
          };
        }
        if (callback != null) {
          _animating[key].callback = callback;
          callback = null;
        }
        if ((_ref4 = (_base = _animating[key])[property]) == null) {
          _base[property] = [];
        }
        _results.push(_animating[key][property] = _animating[key][property].concat(steps));
      }
      return _results;
    };
    animate.update = update;
    for (name in settings) {
      if (!__hasProp.call(settings, name)) continue;
      setting = settings[name];
      animate[name] = setting;
    }
    return animate;
  })();

  (typeof exports !== "undefined" && exports !== null ? exports : this).Animate = Animate;

}).call(this);
