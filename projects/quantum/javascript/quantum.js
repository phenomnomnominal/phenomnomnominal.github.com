// Generated by CoffeeScript 1.3.3
(function() {
  var Bra, BraConstructorError, Complex, ComplexConstructorError, ComplexMathError, Hermitian, HermitianConstructorError, Ket, KetConstructorError, Matrix, MatrixConstructorError, MatrixMathError, Quantum, Unitary, UnitaryConstructorError, apply, checkInput, clear, clearInfoBar, create, display, drop, err, info, infoBar, kron, root, runAlgorithm, select, selectReset, sub, timeouts, transition, warn,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  ComplexConstructorError = (function(_super) {

    __extends(ComplexConstructorError, _super);

    function ComplexConstructorError() {
      return ComplexConstructorError.__super__.constructor.apply(this, arguments);
    }

    return ComplexConstructorError;

  })(Error);

  ComplexMathError = (function(_super) {

    __extends(ComplexMathError, _super);

    function ComplexMathError() {
      return ComplexMathError.__super__.constructor.apply(this, arguments);
    }

    return ComplexMathError;

  })(Error);

  Complex = (function() {

    function Complex(r, i) {
      var ai, ari, bi, bri, cri, imag, realImag, regexImag, regexRealImag, string;
      if (r == null) {
        r = new Complex(0);
      }
      if (i == null) {
        i = 0;
      }
      if (_.isNumber(r) && _.isNumber(i)) {
        this.r = r;
        this.i = i;
      } else if (_.isString(r)) {
        if (!_.isNaN(+r)) {
          return new Complex(+r);
        }
        regexRealImag = /^([-+]?(?:\d+|\d*\.\d+)+)([-+]?(?:\d+|\d*\.\d+)?)?[i]$/i;
        regexImag = /^([-+]?(?:\d+|\d*\.\d+)?)?[i]$/i;
        string = r.replace(/\s+/g, "");
        realImag = string.match(regexRealImag);
        imag = string.match(regexImag);
        if (!((realImag != null) || (imag != null))) {
          throw ComplexConstructorError('Invalid string input: expecting a +/- bi format.');
        }
        if (realImag != null) {
          ari = realImag[0], bri = realImag[1], cri = realImag[2];
        }
        if (imag != null) {
          ai = imag[0], bi = imag[1];
        }
        if ((realImag != null) && (imag != null)) {
          this.r = 0;
          this.i = +bi;
        }
        if ((realImag != null) && !(imag != null)) {
          if (cri === '-') {
            cri = -1;
          }
          if (cri === '+') {
            cri = 1;
          }
          this.r = +bri;
          this.i = +cri;
        }
        if (!(realImag != null) && (imag != null)) {
          if (!(bi != null)) {
            this.r = 0;
            this.i = 1;
          }
          if (bi === '-') {
            this.r = 0;
            this.i = -1;
          }
        }
      } else if (r instanceof Complex) {
        this.r = r.r;
        this.i = r.i;
      } else {
        throw ComplexConstructorError('Incorrect Complex constructor arguments.');
      }
    }

    Complex.prototype.toString = function() {
      var i, r;
      r = this.r % 1 === 0 ? Math.floor(this.r) : this.r.toFixed(2);
      i = this.i % 1 === 0 ? Math.floor(this.i) : this.i.toFixed(2);
      if (r !== 0 && i === 0) {
        return "" + r;
      } else if (i !== 0 && r === 0) {
        if (i === -1) {
          return "-i";
        } else if (i === 1) {
          return "i";
        } else {
          return "" + i + "i";
        }
      } else if (r !== 0 && i !== 0) {
        return "" + r + " + " + i + "i";
      } else if (r === 0 && i === 0) {
        return "0";
      }
    };

    Complex.prototype.add = function(n) {
      var c;
      c = new Complex(n);
      this.r += c.r;
      this.i += c.i;
      return this;
    };

    Complex.prototype.subtract = function(n) {
      var c;
      c = new Complex(n);
      this.r -= c.r;
      this.i -= c.i;
      return this;
    };

    Complex.prototype.multiply = function(n) {
      var a, b, c;
      c = new Complex(n);
      a = this.r;
      b = this.i;
      this.r = a * c.r - b * c.i;
      this.i = b * c.r + a * c.i;
      return this;
    };

    Complex.prototype.divide = function(n) {
      var a, b, c, denominator;
      c = new Complex(n);
      if (c.r === 0 && c.i === 0) {
        throw ComplexMathError('Divide: argument `c` cannot be 0 + 0i.');
      }
      denominator = c.r * c.r + c.i * c.i;
      a = this.r;
      b = this.i;
      this.r = (a * c.r + b * c.i) / denominator;
      this.i = (b * c.r - a * c.i) / denominator;
      return this;
    };

    Complex.prototype.exp = function() {
      this.r = Math.cos(this.i);
      this.i = Math.sin(this.i);
      return this;
    };

    Complex.prototype.mag = function() {
      return Math.sqrt(this.r * this.r + this.i * this.i);
    };

    Complex.prototype.conjugate = function() {
      this.i *= -1;
      return this;
    };

    Complex.prototype.equals = function(n) {
      var abs, c, diffI, diffR, sign;
      c = new Complex(n);
      abs = Math.abs;
      sign = function(val) {
        if (val >= 0) {
          return 1;
        } else {
          return -1;
        }
      };
      if (sign(this.r) === sign(c.r) && sign(this.i) === sign(c.i)) {
        diffR = abs(this.r) - abs(c.r);
        diffI = abs(this.i) - abs(c.i);
        if ((-1e-10 < diffR && diffR < 1e-10) && (-1e-10 < diffI && diffI < 1e-10)) {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    };

    Complex.Add = function(a, b) {
      a = new Complex(a);
      b = new Complex(b);
      return a.add(b);
    };

    Complex.Subtract = function(a, b) {
      a = new Complex(a);
      b = new Complex(b);
      return a.subtract(b);
    };

    Complex.Multiply = function(a, b) {
      a = new Complex(a);
      b = new Complex(b);
      return a.multiply(b);
    };

    Complex.Divide = function(a, b) {
      a = new Complex(a);
      b = new Complex(b);
      return a.divide(b);
    };

    Complex.Exp = function(n) {
      var c;
      c = new Complex(n);
      return c.exp();
    };

    Complex.Mag = function(n) {
      var c;
      c = new Complex(n);
      return c.mag();
    };

    Complex.Conjugate = function(n) {
      var c;
      c = new Complex(n);
      return c.conjugate();
    };

    Complex.Equals = function(a, b) {
      a = new Complex(a);
      b = new Complex(b);
      return a.equals(b);
    };

    return Complex;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.$C = root.Complex = Complex;

  BraConstructorError = (function(_super) {

    __extends(BraConstructorError, _super);

    function BraConstructorError() {
      return BraConstructorError.__super__.constructor.apply(this, arguments);
    }

    return BraConstructorError;

  })(Error);

  KetConstructorError = (function(_super) {

    __extends(KetConstructorError, _super);

    function KetConstructorError() {
      return KetConstructorError.__super__.constructor.apply(this, arguments);
    }

    return KetConstructorError;

  })(Error);

  Bra = (function() {

    function Bra(row, constant) {
      var v, _i, _ref;
      this.row = row;
      if (constant == null) {
        constant = 1;
      }
      if (this.row == null) {
        throw BraConstructorError('`row` must be defined.');
      }
      if (!_.isArray(this.row)) {
        throw BraConstructorError('`row` must be an Array.');
      }
      if (!_.isNumber(constant)) {
        throw BraConstructorError('`constant` must be a Number');
      }
      for (v = _i = 0, _ref = this.row.length; 0 <= _ref ? _i < _ref : _i > _ref; v = 0 <= _ref ? ++_i : --_i) {
        this.row[v] = new $C(this.row[v]).multiply(constant);
      }
      this.size = this.row.length;
    }

    return Bra;

  })();

  Ket = (function() {
    var toBra;

    function Ket(col, constant) {
      var v, _i, _ref,
        _this = this;
      this.col = col;
      if (constant == null) {
        constant = 1;
      }
      if (this.col == null) {
        throw KetConstructorError('`col` must be defined.');
      }
      if (!_.isArray(this.col)) {
        throw KetConstructorError('`col` must be an Array.');
      }
      if (!_.isNumber(constant)) {
        throw KetConstructorError('`constant` must be a Number');
      }
      this.size = this.col.length;
      for (v = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; v = 0 <= _ref ? ++_i : --_i) {
        this.col[v] = new $C(this.col[v]).multiply(constant);
      }
      this.sumAbsSqrd = _.reduce(col, (function(p, n) {
        return p + Math.pow(n.mag(), 2);
      }), 0);
    }

    Ket.Zero = function() {
      return new $K([new $C(1), new $C(0)]);
    };

    Ket.One = function() {
      return new $K([new $C(0), new $C(1)]);
    };

    Ket.prototype.print = function(id) {
      var c, _i, _len, _ref;
      console.log("" + id + " KET:");
      _ref = this.col;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        console.log("" + c);
      }
      return this;
    };

    toBra = function(ket) {
      var row, val;
      row = (function() {
        var _i, _len, _ref, _results;
        _ref = ket.col;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          val = _ref[_i];
          _results.push(new $C(val).conjugate());
        }
        return _results;
      })();
      return new Bra(row);
    };

    Ket.prototype.probability = function(n) {
      var precision, rounded;
      if (this.sumAbsSqrd !== 0) {
        precision = +(Math.pow(this.col[n].mag(), 2) / this.sumAbsSqrd).toPrecision(10);
        rounded = Math.round(precision);
        if (Math.abs(precision - rounded) < 1e-10) {
          return rounded;
        } else {
          return precision;
        }
      } else {
        return 0;
      }
    };

    Ket.prototype.normalise = function() {
      var v;
      if (this.sumAbsSqrd !== 0) {
        this.col = (function() {
          var _i, _ref, _results;
          _results = [];
          for (v = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; v = 0 <= _ref ? ++_i : --_i) {
            _results.push(this.col[v].divide(Math.sqrt(this.sumAbsSqrd)));
          }
          return _results;
        }).call(this);
        this.sumAbsSqrd = 1;
      }
      return this;
    };

    Ket.prototype.transition = function(ket) {
      var bra, dotProduct, _i, _ref, _results,
        _this = this;
      bra = toBra(ket);
      return dotProduct = _.reduce((function() {
        _results = [];
        for (var _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this), function(p, n) {
        return p.add(bra.row[n].multiply(_this.col[n]));
      }, new $C(0));
    };

    Ket.prototype.ignore = function(n) {
      var endN, i, p, startN, val, _i, _j, _ref,
        _this = this;
      this.normalise();
      val = [];
      for (i = _i = 0, _ref = this.col.length / Math.pow(2, n); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        startN = Math.pow(2, n) * i;
        endN = startN + Math.pow(2, n);
        val[i] = new $C(0);
        for (p = _j = startN; startN <= endN ? _j < endN : _j > endN; p = startN <= endN ? ++_j : --_j) {
          val[i].add(new $C(this.probability(p)));
        }
      }
      this.col = val;
      this.size = val.length;
      this.sumAbsSqrd = _.reduce(this.col, (function(p, n) {
        return p + Math.pow(n.mag(), 2);
      }), 0);
      return this;
    };

    Ket.Combine = function(ket1, ket2) {
      var ket1Col, ket1Mat, ket2Col, ket2Mat, v;
      ket1Col = (function() {
        var _i, _len, _ref, _results;
        _ref = ket1.col;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push([v]);
        }
        return _results;
      })();
      ket1Mat = new $M(ket1Col);
      ket2Col = (function() {
        var _i, _len, _ref, _results;
        _ref = ket2.col;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push([v]);
        }
        return _results;
      })();
      ket2Mat = new $M(ket2Col);
      return new $K(_.flatten($M.Kron([ket1Mat, ket2Mat]).matrix));
    };

    Ket.ApplyGate = function(gate, ket) {
      var col, ketMat, result, v;
      col = (function() {
        var _i, _len, _ref, _results;
        _ref = ket.col;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push([v]);
        }
        return _results;
      })();
      ketMat = new Matrix(col);
      result = Matrix.Multiply(gate, ketMat);
      col = _.flatten(result.matrix);
      return new Ket(col);
    };

    return Ket;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.$K = root.Ket = Ket;

  MatrixConstructorError = (function(_super) {

    __extends(MatrixConstructorError, _super);

    function MatrixConstructorError() {
      return MatrixConstructorError.__super__.constructor.apply(this, arguments);
    }

    return MatrixConstructorError;

  })(Error);

  MatrixMathError = (function(_super) {

    __extends(MatrixMathError, _super);

    function MatrixMathError() {
      return MatrixMathError.__super__.constructor.apply(this, arguments);
    }

    return MatrixMathError;

  })(Error);

  HermitianConstructorError = (function(_super) {

    __extends(HermitianConstructorError, _super);

    function HermitianConstructorError() {
      return HermitianConstructorError.__super__.constructor.apply(this, arguments);
    }

    return HermitianConstructorError;

  })(Error);

  UnitaryConstructorError = (function(_super) {

    __extends(UnitaryConstructorError, _super);

    function UnitaryConstructorError() {
      return UnitaryConstructorError.__super__.constructor.apply(this, arguments);
    }

    return UnitaryConstructorError;

  })(Error);

  Matrix = (function() {
    var clone;

    function Matrix(m, constant) {
      var complexM, length, n, obj, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _ref, _ref1, _ref2;
      if (constant == null) {
        constant = 1;
      }
      if (m == null) {
        throw MatrixConstructorError('`m` must be defined.');
      }
      if (!_.isArray(m)) {
        throw MatrixConstructorError('`m` must be an Array.');
      }
      for (_i = 0, _len = m.length; _i < _len; _i++) {
        obj = m[_i];
        if (!_.isArray(obj)) {
          throw MatrixConstructorError('`m` must be a 2D Array.');
        }
      }
      if (!(m.length > 0)) {
        throw MatrixConstructorError('`m` must have more than 0 rows.');
      }
      length = -1;
      for (_j = 0, _len1 = m.length; _j < _len1; _j++) {
        n = m[_j];
        if (length < 0) {
          length = n.length;
        }
        if (n.length !== length) {
          throw MatrixConstructorError('`m` must contain rows of one length.');
        }
      }
      if (!(length > 0)) {
        throw MatrixConstructorError('`m` must have more than 0 columns.');
      }
      for (_k = 0, _len2 = m.length; _k < _len2; _k++) {
        n = m[_k];
        for (_l = 0, _len3 = n.length; _l < _len3; _l++) {
          obj = n[_l];
          if (!(obj instanceof $C)) {
            throw MatrixConstructorError('`m` must only contain Complex numbers.');
          }
        }
      }
      complexM = [];
      for (x = _m = 0, _ref = m.length; 0 <= _ref ? _m < _ref : _m > _ref; x = 0 <= _ref ? ++_m : --_m) {
        for (y = _n = 0, _ref1 = m[x].length; 0 <= _ref1 ? _n < _ref1 : _n > _ref1; y = 0 <= _ref1 ? ++_n : --_n) {
          if ((_ref2 = complexM[x]) == null) {
            complexM[x] = [];
          }
          complexM[x][y] = new $C(m[x][y]).multiply(constant);
        }
      }
      this.matrix = complexM;
      this.rows = this.matrix.length;
      this.columns = this.matrix[0].length;
    }

    Matrix.Identity = function(n) {
      var c, matrix, r, _i, _j;
      if (n == null) {
        n = 1;
      }
      n = Math.pow(2, n);
      matrix = [];
      for (r = _i = 0; 0 <= n ? _i < n : _i > n; r = 0 <= n ? ++_i : --_i) {
        matrix[r] = [];
        for (c = _j = 0; 0 <= n ? _j < n : _j > n; c = 0 <= n ? ++_j : --_j) {
          matrix[r][c] = r === c ? new $C(1) : new $C(0);
        }
      }
      return new Matrix(matrix);
    };

    Matrix.Ones = function(n) {
      var c, matrix, r, _i, _j;
      if (n == null) {
        n = 1;
      }
      n = Math.pow(2, n);
      matrix = [];
      for (r = _i = 0; 0 <= n ? _i < n : _i > n; r = 0 <= n ? ++_i : --_i) {
        matrix[r] = [];
        for (c = _j = 0; 0 <= n ? _j < n : _j > n; c = 0 <= n ? ++_j : --_j) {
          matrix[r][c] = new $C(1);
        }
      }
      return new Matrix(matrix);
    };

    Matrix.Zeroes = function(n) {
      var c, matrix, r, _i, _j;
      if (n == null) {
        n = 1;
      }
      n = Math.pow(2, n);
      matrix = [];
      for (r = _i = 0; 0 <= n ? _i < n : _i > n; r = 0 <= n ? ++_i : --_i) {
        matrix[r] = [];
        for (c = _j = 0; 0 <= n ? _j < n : _j > n; c = 0 <= n ? ++_j : --_j) {
          matrix[r][c] = new $C(0);
        }
      }
      return new Matrix(matrix);
    };

    Matrix.prototype.print = function(id) {
      var c, r, str, _i, _j, _ref, _ref1;
      console.log("" + id + " MATRIX:");
      for (r = _i = 0, _ref = this.rows; 0 <= _ref ? _i < _ref : _i > _ref; r = 0 <= _ref ? ++_i : --_i) {
        str = '[';
        for (c = _j = 0, _ref1 = this.columns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
          str += "" + this.matrix[r][c] + ", ";
        }
        str = "" + str.slice(0, str.length - 2) + "]";
        console.log(str);
      }
      return this;
    };

    Matrix.prototype.scale = function(s) {
      var c, r, _i, _j, _ref, _ref1;
      for (r = _i = 0, _ref = this.rows; 0 <= _ref ? _i < _ref : _i > _ref; r = 0 <= _ref ? ++_i : --_i) {
        for (c = _j = 0, _ref1 = this.columns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
          this.matrix[r][c].multiply(s);
        }
      }
      return this;
    };

    Matrix.prototype.negate = function() {
      return this.scale(-1);
    };

    Matrix.prototype.transpose = function() {
      var c, r, trans, _i, _j, _ref, _ref1;
      trans = clone(this);
      for (r = _i = 0, _ref = this.rows; 0 <= _ref ? _i < _ref : _i > _ref; r = 0 <= _ref ? ++_i : --_i) {
        for (c = _j = 0, _ref1 = this.columns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
          trans.matrix[c][r] = this.matrix[r][c];
        }
      }
      return trans;
    };

    Matrix.prototype.conj = function() {
      var c, conj, r, _i, _j, _ref, _ref1;
      conj = clone(this);
      for (r = _i = 0, _ref = this.rows; 0 <= _ref ? _i < _ref : _i > _ref; r = 0 <= _ref ? ++_i : --_i) {
        for (c = _j = 0, _ref1 = this.columns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
          conj.matrix[r][c] = this.matrix[r][c].conjugate();
        }
      }
      return conj;
    };

    Matrix.prototype.isUnitary = function() {
      var conjTrans;
      if (this.rows !== this.columns) {
        return false;
      } else {
        this.size = this.rows;
        conjTrans = clone(this).conj().transpose();
        if (Matrix.Multiply(this, conjTrans).isIdentity()) {
          return true;
        } else {
          return false;
        }
      }
    };

    Matrix.prototype.isHermitian = function() {
      var c, conj, r, val, _i, _j, _ref, _ref1;
      if (this.rows !== this.columns) {
        return false;
      } else {
        this.size = this.rows;
        for (r = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; r = 0 <= _ref ? ++_i : --_i) {
          for (c = _j = 0, _ref1 = this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
            val = this.matrix[r][c];
            conj = $C.Conjugate(this.matrix[c][r]);
            if (!$C.Equals(val, conj)) {
              return false;
            }
          }
        }
        return true;
      }
    };

    Matrix.prototype.isIdentity = function() {
      var c, r, _i, _j, _ref, _ref1;
      if (this.rows !== this.columns) {
        return false;
      } else {
        for (r = _i = 0, _ref = this.rows; 0 <= _ref ? _i < _ref : _i > _ref; r = 0 <= _ref ? ++_i : --_i) {
          for (c = _j = 0, _ref1 = this.columns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
            if (r === c) {
              if (!this.matrix[r][c].equals(new $C(1))) {
                return false;
              }
            } else {
              if (!this.matrix[r][c].equals(new $C(0))) {
                return false;
              }
            }
          }
        }
        return true;
      }
    };

    clone = function(m) {
      return new Matrix(m.matrix);
    };

    Matrix.Add = function() {
      var add, i, j, m, m1, m2, mn, result, _i, _j, _k, _len, _ref, _ref1;
      m1 = arguments[0], m2 = arguments[1], mn = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (m1.columns !== m2.columns && m1.rows !== m2.rows) {
        throw MatrixMathError('Matrix dimensions incorrect for addition.');
      }
      result = [];
      for (i = _i = 0, _ref = m1.rows; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        result[i] = [];
        for (j = _j = 0, _ref1 = m1.columns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          result[i][j] = $C.Add(m1.matrix[i][j], m2.matrix[i][j]);
        }
      }
      add = new Matrix(result);
      for (_k = 0, _len = mn.length; _k < _len; _k++) {
        m = mn[_k];
        add = Matrix.Multiply(add, m);
      }
      return add;
    };

    Matrix.Multiply = function() {
      var c, i, k, m, m1, m2, mn, mul, r, result, val, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
      m1 = arguments[0], m2 = arguments[1], mn = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (m1.columns !== m2.rows) {
        throw MatrixMathError('Matrix dimensions incorrect for multiplication.');
      }
      result = [];
      for (i = _i = 0, _ref = m1.rows; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        result.push([]);
      }
      for (r = _j = 0, _ref1 = m1.rows; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; r = 0 <= _ref1 ? ++_j : --_j) {
        for (c = _k = 0, _ref2 = m2.columns; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; c = 0 <= _ref2 ? ++_k : --_k) {
          val = new $C(0);
          for (k = _l = 0, _ref3 = m1.columns; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; k = 0 <= _ref3 ? ++_l : --_l) {
            val.add($C.Multiply(m1.matrix[r][k], m2.matrix[k][c]));
          }
          result[r][c] = val;
        }
      }
      mul = new Matrix(result);
      for (_m = 0, _len = mn.length; _m < _len; _m++) {
        m = mn[_m];
        mul = Matrix.Multiply(mul, m);
      }
      return mul;
    };

    Matrix.Kron = function(matrices) {
      var height1, height2, kronProd, m, m1, m2, n, newM, newN, p, q, val, width1, width2, _i, _j, _k, _l, _m, _ref;
      if (matrices.length === 1) {
        return matrices[0];
      } else {
        m1 = matrices[0];
        m2 = matrices[1];
        kronProd = [];
        height1 = m1.rows;
        width1 = m1.columns;
        height2 = m2.rows;
        width2 = m2.columns;
        for (m = _i = 0, _ref = height1 * height2; 0 <= _ref ? _i < _ref : _i > _ref; m = 0 <= _ref ? ++_i : --_i) {
          kronProd.push([]);
        }
        for (m = _j = 0; 0 <= height1 ? _j < height1 : _j > height1; m = 0 <= height1 ? ++_j : --_j) {
          for (n = _k = 0; 0 <= width1 ? _k < width1 : _k > width1; n = 0 <= width1 ? ++_k : --_k) {
            for (p = _l = 0; 0 <= height2 ? _l < height2 : _l > height2; p = 0 <= height2 ? ++_l : --_l) {
              for (q = _m = 0; 0 <= width2 ? _m < width2 : _m > width2; q = 0 <= width2 ? ++_m : --_m) {
                newM = m * height2 + p;
                newN = n * width2 + q;
                val = $C.Multiply(m1.matrix[m][n], m2.matrix[p][q]);
                kronProd[newM][newN] = val;
              }
            }
          }
        }
        return Matrix.Kron([new Matrix(kronProd)].concat(matrices.slice(2)));
      }
    };

    return Matrix;

  })();

  Hermitian = (function(_super) {

    __extends(Hermitian, _super);

    function Hermitian(m, constant) {
      if (constant == null) {
        constant = 1;
      }
      Hermitian.__super__.constructor.call(this, m, constant);
      if (!this.isHermitian()) {
        throw HermitianConstructorError('Matrix is not Hermitian.');
      }
    }

    return Hermitian;

  })(Matrix);

  Unitary = (function(_super) {

    __extends(Unitary, _super);

    function Unitary(m, constant) {
      if (constant == null) {
        constant = 1;
      }
      Unitary.__super__.constructor.call(this, m, constant);
      if (!this.isUnitary()) {
        throw UnitaryConstructorError('Matrix is not Unitary.');
      }
    }

    Unitary.PauliX = function() {
      return new Unitary([[new $C(0), new $C(1)], [new $C(1), new $C(0)]]);
    };

    Unitary.PauliY = function() {
      return new Unitary([[new $C(0), new $C('-i')], [new $C('i'), new $C(0)]]);
    };

    Unitary.PauliZ = function() {
      return new Unitary([[new $C(1), new $C(0)], [new $C(0), new $C(-1)]]);
    };

    Unitary.S = function() {
      return new Unitary([[new $C(1), new $C(0)], [new $C(0), new $C('i')]]);
    };

    Unitary.T = function(θ) {
      var e, iθ, π;
      e = $C.Exp;
      π = Math.PI;
      if (!(θ != null)) {
        θ = π / 4;
      }
      iθ = new $C('i').multiply(θ);
      return new Unitary([[new $C(1), new $C(0)], [new $C(0), e(iθ)]]);
    };

    Unitary.Hadamard = function() {
      var oneOverRoot2;
      oneOverRoot2 = 1 / Math.sqrt(2);
      return new Unitary([[new $C(1), new $C(1)], [new $C(1), new $C(-1)]], oneOverRoot2);
    };

    Unitary.SqrtNot = function() {
      var oneOverRoot2;
      oneOverRoot2 = 1 / Math.sqrt(2);
      return new Unitary([[new $C(1), new $C(-1)], [new $C(1), new $C(1)]], oneOverRoot2);
    };

    Unitary.CreateNBitDeutschJozsaOracle = function(n, solution) {
      var fx, i, matrix, range, x, xy, xyXORfx, y, yXORfx, _i, _j, _ref, _ref1, _results;
      range = (function() {
        _results = [];
        for (var _i = 0, _ref = 2 * Math.pow(2, n); 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      x = _.flatten((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (i = _j = 0, _ref1 = range.length / 2; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push([i, i]);
        }
        return _results1;
      })());
      y = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = range.length; _j < _len; _j++) {
          i = range[_j];
          _results1.push(i % 2);
        }
        return _results1;
      })();
      solution = solution.toString(2);
      while (solution.length < range.length / 2) {
        solution = "0" + solution;
      }
      fx = _.flatten((function() {
        var _j, _len, _ref1, _results1;
        _ref1 = solution.split('');
        _results1 = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          i = _ref1[_j];
          _results1.push([i, i]);
        }
        return _results1;
      })());
      yXORfx = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = range.length; _j < _len; _j++) {
          i = range[_j];
          _results1.push(y[i] ^ fx[i]);
        }
        return _results1;
      })();
      xy = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = range.length; _j < _len; _j++) {
          i = range[_j];
          _results1.push(parseInt("" + (x[i].toString(2)) + (y[i].toString(2)), 2));
        }
        return _results1;
      })();
      xyXORfx = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = range.length; _j < _len; _j++) {
          i = range[_j];
          _results1.push(parseInt("" + (x[i].toString(2)) + (yXORfx[i].toString(2)), 2));
        }
        return _results1;
      })();
      matrix = $M.Zeroes(n + 1);
      for (i = _j = 0, _ref1 = xy.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        matrix.matrix[xy[i]][xyXORfx[i]] = new $C(1);
      }
      return matrix;
    };

    Unitary.CreateNBitHaystack = function(n, solution) {
      var matrix;
      if (solution >= Math.pow(2, n) || solution < 0) {
        throw MatrixMathError('The solution must be smaller than 2^n and greater than 0.');
      }
      matrix = $U.Identity(n + 1).matrix;
      matrix[2 * solution][2 * solution] = new $C(0);
      matrix[2 * solution][2 * solution + 1] = new $C(1);
      matrix[2 * solution + 1][2 * solution] = new $C(1);
      matrix[2 * solution + 1][2 * solution + 1] = new $C(0);
      return new $U(matrix);
    };

    return Unitary;

  })(Matrix);

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.$M = root.Matrix = Matrix;

  root.$O = root.Hermitian = Hermitian;

  root.$U = root.Unitary = Unitary;

  Quantum = {
    Deutsch: function(oracle) {
      var HkH, HkI, answer, results, x, y, ϕ0, ϕ1, ϕ2, ϕ3, ϕ4;
      x = $K.Zero();
      y = $K.One();
      ϕ0 = $K.Combine(x, y);
      HkH = $M.Kron([$U.Hadamard(), $U.Hadamard()]);
      ϕ1 = $K.ApplyGate(HkH, ϕ0);
      ϕ2 = $K.ApplyGate(oracle, ϕ1);
      HkI = $M.Kron([$U.Hadamard(), $U.Identity()]);
      ϕ3 = $K.ApplyGate(HkI, ϕ2);
      ϕ4 = new $K(ϕ3.col);
      ϕ4.ignore(1);
      answer = function(ket) {
        if (ket.probability(0) === 1) {
          return 'Constant';
        } else if (ket.probability(0) === 0) {
          return 'Balanced';
        }
      };
      return results = {
        'ϕ<sub>0</sub>': ϕ0,
        'H⊗H': HkH,
        'ϕ<sub>1</sub> = H⊗H → ϕ<sub>0</sub>': ϕ1,
        'U<sub>ƒ</sub>': oracle,
        'ϕ<sub>2</sub> = Oracle → ϕ<sub>1</sub>': ϕ2,
        'H⊗I': HkI,
        'ϕ<sub>3</sub> = H⊗I → ϕ<sub>2</sub>': ϕ3,
        'answer': answer(ϕ4)
      };
    },
    DeutschJozsa: function(oracle, n) {
      var HkN, HkNkH, HkNkI, answer, i, results, x, xn, y, ϕ0, ϕ1, ϕ2, ϕ3, ϕ4,
        _this = this;
      xn = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= n ? _i < n : _i > n; i = 1 <= n ? ++_i : --_i) {
          _results.push($K.Zero());
        }
        return _results;
      })();
      x = _.reduce(xn, function(p, n) {
        return $K.Combine(p, n);
      }, $K.Zero());
      y = $K.One();
      HkN = $M.Kron((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          _results.push($U.Hadamard());
        }
        return _results;
      })());
      HkNkH = $M.Kron([HkN, $U.Hadamard()]);
      HkNkI = $M.Kron([HkN, $U.Identity()]);
      ϕ0 = $K.Combine(x, y).normalise();
      ϕ1 = $K.ApplyGate(HkNkH, ϕ0).normalise();
      ϕ2 = $K.ApplyGate(oracle, ϕ1);
      ϕ3 = $K.ApplyGate(HkNkI, ϕ2).normalise();
      ϕ4 = new $K(ϕ3.col);
      ϕ4.ignore(1);
      answer = function(ket) {
        if (ket.probability(0) === 1) {
          return 'Constant';
        } else if (ket.probability(0) === 0) {
          return 'Balanced';
        } else {
          return 'Not Constant or Balanced';
        }
      };
      return results = {
        'ϕ<sub>0</sub>': ϕ0,
        'H<sup>⊗N+1</sup>': HkNkH,
        'ϕ<sub>1</sub> = H<sup>⊗N+1</sup> → ϕ<sub>0</sub>': ϕ1,
        'U<sub>ƒ</sub>': oracle,
        'ϕ<sub>2</sub> = Oracle → ϕ<sub>1</sub>': ϕ2,
        'H<sup>⊗N</sup>⊗I': HkNkI,
        'ϕ<sub>3</sub> = H<sup>⊗N</sup>⊗I → ϕ<sub>2</sub>': ϕ3,
        'answer': answer(ϕ4)
      };
    },
    Grover: function(oracle) {
      var HkN, HkNkH, HkNkI, answer, i, invMean, invMeankI, key, n, negI, origϕ1, results, val, x, xn, y, μ, ϕ0, ϕ1, ϕ2, ϕ2a, ϕ2b, ϕ3, ϕ4, _i, _j, _ref, _ref1, _ref2,
        _this = this;
      n = Math.log(oracle.size / 2) / Math.LN2;
      xn = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= n ? _i < n : _i > n; i = 1 <= n ? ++_i : --_i) {
          _results.push($K.Zero());
        }
        return _results;
      })();
      x = _.reduce(xn, function(p, n) {
        return $K.Combine(p, n);
      }, $K.Zero());
      y = new $K([new $C(0), new $C(1)]);
      HkN = $M.Kron((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          _results.push($U.Hadamard());
        }
        return _results;
      })());
      HkNkH = $M.Kron([HkN, $U.Hadamard()]);
      HkNkI = $M.Kron([HkN, $U.Identity()]);
      negI = $M.Identity(n).negate();
      μ = $M.Ones(n).scale(2 / Math.pow(2, n));
      invMean = $M.Add(negI, μ);
      invMeankI = $M.Kron([invMean, $U.Identity()]);
      ϕ0 = $K.Combine(x, y);
      ϕ1 = $K.ApplyGate(HkNkH, ϕ0);
      origϕ1 = new $K(ϕ1.col);
      ϕ2 = [];
      for (i = _i = 0, _ref = Math.max(Math.floor((Math.PI / 4) * Math.sqrt(Math.pow(2, n))), 2); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        ϕ2a = $K.ApplyGate(oracle, ϕ1);
        ϕ2b = $K.ApplyGate(invMeankI, ϕ2a);
        ϕ2[i] = {
          'ϕ2a': ϕ2a,
          'ϕ2b': ϕ2b
        };
        ϕ1 = ϕ2b;
      }
      ϕ3 = ϕ1;
      ϕ4 = new $K(ϕ3.col);
      ϕ4.ignore(1);
      answer = function(ket) {
        var j, samples, str, _j, _k, _ref1, _ref2;
        samples = [];
        for (i = _j = 0, _ref1 = ket.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          for (j = _k = 0, _ref2 = ket.probability(i) * 1000; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
            samples.push(i);
          }
        }
        str = samples[Math.floor(Math.random() * samples.length)].toString(2);
        while (str.length < n) {
          str = "0" + str;
        }
        return "'" + str + "'";
      };
      results = {
        'ϕ<sub>0</sub>': ϕ0,
        'H<sup>⊗N+1</sup>': HkNkH,
        'ϕ<sub>1</sub><sup>1</sup> = H<sup>⊗N+1</sup> → ϕ<sub>0</sub>': origϕ1,
        'U<sub>ƒ</sub>': oracle,
        '(µ<sup>-1</sup>)<sup>⊗I</sup>': invMeankI,
        'answer': answer(ϕ4)
      };
      for (i = _j = 0, _ref1 = ϕ2.length - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _ref2 = ϕ2[i];
        for (key in _ref2) {
          if (!__hasProp.call(_ref2, key)) continue;
          val = _ref2[key];
          if (key === 'ϕ2a') {
            results["ϕ<sub>2a</sub><sup>" + (i + 1) + "</sup> = Oracle → ϕ<sub>1</sub><sup>" + (i + 1) + "</sup>"] = val;
          }
          if (key === 'ϕ2b') {
            results["ϕ<sub>2b</sub><sup>" + (i + 1) + "</sup> = (µ<sup>-1</sup>)<sup>⊗I</sup> → ϕ<sub>2a</sub><sup>" + (i + 1) + "</sup>"] = val;
            if (i < ϕ2.length - 2) {
              results["ϕ<sub>1</sub><sup>" + (i + 2) + "</sup> = ϕ<sub>2b</sub><sup>" + (i + 1) + "</sup>"] = val;
            } else {
              results["ϕ<sub>3</sub> = ϕ<sub>2b</sub><sup>" + (i + 1) + "</sup>"] = val;
            }
          }
        }
      }
      return results;
    },
    Shor: function(N) {
      var a, aRmodN, aRmodNVals, c, f1, f2, gcd, isPrime, mod, period, r, result;
      result = null;
      isPrime = function(N) {
        var i, j, n, primes, _i, _j, _ref, _ref1;
        primes = (function() {
          var _i, _results;
          _results = [];
          for (n = _i = 0; 0 <= N ? _i <= N : _i >= N; n = 0 <= N ? ++_i : --_i) {
            _results.push(true);
          }
          return _results;
        })();
        primes[0] = false;
        primes[1] = false;
        for (i = _i = 2, _ref = Math.sqrt(N); 2 <= _ref ? _i <= _ref : _i >= _ref; i = 2 <= _ref ? ++_i : --_i) {
          if (primes[i]) {
            for (j = _j = _ref1 = Math.pow(i, 2); _ref1 <= N ? _j <= N : _j >= N; j = _j += i) {
              primes[j] = false;
            }
          }
        }
        return primes[N];
      };
      if (isPrime(N)) {
        return [1, N];
      }
      a = Math.floor(Math.random() * N) + 2;
      gcd = function(a, b) {
        if (b === 0) {
          return a;
        } else {
          return gcd(b, a % b);
        }
      };
      c = gcd(a, N);
      if (c !== 1) {
        result = [N / c, N / (N / c)];
      }
      mod = function(a, b) {
        return ((a % b) + b) % b;
      };
      if (!(result != null)) {
        aRmodNVals = [1];
        r = 1;
        while (aRmodN !== 1) {
          aRmodN = mod(Math.pow(a, r), N);
          r++;
          aRmodNVals = [aRmodN].concat(aRmodNVals);
          if (_.isNaN(aRmodN)) {
            break;
          }
        }
        period = r - 1;
        if (mod(period, 2) === 1 || Math.pow(a, period / 2) === mod(-1, N) || _.isNaN(aRmodNVals[0])) {
          return Quantum.Shor(N);
        }
        result = [gcd(Math.pow(a, period / 2) + 1, N), gcd(Math.pow(a, period / 2) - 1, N)];
        if (result[0] === result[1]) {
          return Quantum.Shor(N);
        } else {
          return result;
        }
      }
      f1 = result[0], f2 = result[1];
      return [f1, f2];
    }
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.Quantum = Quantum;

  this.quantumComputer = {
    kets: {},
    gates: []
  };

  sub = '<sub> </sub>';

  timeouts = [];

  infoBar = function(selector, level, message) {
    var timeout, _i, _len;
    if (message == null) {
      message = '';
    }
    for (_i = 0, _len = timeouts.length; _i < _len; _i++) {
      timeout = timeouts[_i];
      clearTimeout(timeout);
    }
    $(selector).removeClass().addClass(level);
    if (level !== 'default') {
      (function(times, count) {
        var callee;
        if (count == null) {
          count = 0;
        }
        if (count < times) {
          $(selector).toggleClass("" + level + "Flash");
          callee = arguments.callee;
          return timeouts.push(setTimeout((function() {
            return callee(times, count + 1);
          }), 500));
        } else {
          return clearInfoBar(selector);
        }
      })(10);
    }
    return $(selector).html(message);
  };

  clearInfoBar = function(selector) {
    return infoBar(selector, 'default');
  };

  info = function(message) {
    return infoBar('#infoBar', 'info', message);
  };

  warn = function(message) {
    return infoBar('#infoBar', 'warning', message);
  };

  err = function(message) {
    return infoBar('#infoBar', 'error', message);
  };

  clear = {
    input: function($el, checkVal) {
      if (checkVal != null) {
        if ($el.val() === checkVal) {
          return $el.val('');
        }
      } else {
        return $el.val('');
      }
    },
    element: function($el) {
      return $el.html('');
    },
    transition: function() {
      var transition;
      transition = [null, null];
      $('.transition').text('').removeClass('dropped');
      $('.transition').parent().children('input').remove();
      return $('.transitionAmp').remove();
    },
    apply: function() {
      apply.gate = null;
      apply.ket = null;
      $('.apply').text('').removeClass('dropped');
      return $('.apply').parent().children('input').remove();
    },
    kron: function() {
      var kron;
      kron = [null, null];
      $('.kron').text('').removeClass('dropped');
      return $('.kron').parent().children('input').remove();
    },
    quantum: function() {
      window.quantumComputer = {
        kets: {},
        gates: []
      };
      $('.answer').remove();
      clear.element($('.state'));
      $('#kets').masonry('reload');
      $('#gates').masonry('reload');
      clear.transition();
      clear.apply();
      return clear.kron();
    }
  };

  checkInput = {
    qubit: function(value, maxVal, success, type) {
      var states, val;
      val = +value;
      if (_.isNumber(val) && !_.isNaN(val) && val > 0 && val % 1 === 0) {
        states = Math.pow(2, val);
        if (val > maxVal) {
          if (type === 'KET') {
            warn("YOU PROBABILY DON'T WANT TO INPUT " + states + " PROBABILITIES. TRY AN INTEGER LESS THAN " + (maxVal + 1) + ".");
          }
          if (type === 'GATE') {
            return warn("YOU PROBABILY DON'T WANT TO INPUT " + (Math.pow(states, 2)) + " GATE VALUES. TRY AN INTEGER LESS THAN " + (maxVal + 1) + ".");
          }
        } else {
          return success(states);
        }
      } else {
        val = value;
        if (val !== '') {
          return err("'" + val + "' IS NOT A VALID INPUT. TRY AN INTEGER LESS THAN " + (maxVal + 1) + ".");
        }
      }
    }
  };

  selectReset = function($select) {
    if ($select.children('option').first().text() !== 'SELECT:') {
      $select.prepend($('<option>', {
        text: 'SELECT:'
      }));
      return $select.children('option').first().attr('selected', true);
    }
  };

  runAlgorithm = function(func, args, answerStr, algName) {
    var count, name, result, results;
    $('.answer').remove();
    results = func.apply(this, args);
    count = 1;
    for (name in results) {
      if (!__hasProp.call(results, name)) continue;
      result = results[name];
      if (result instanceof $K) {
        create.ket(result.col, name);
      } else if (result instanceof $M) {
        create.gate(result.matrix, name);
      } else {
        $('#algorithmForm').append("<p class='answer'>" + (answerStr.replace('%s', result)) + ".</p>");
        $('html, body').animate({
          scrollTop: $('.answer').offset().top
        }, 1000);
      }
    }
    return info("" + algName + " ALGORITHM COMPLETED.");
  };

  create = {
    label: function(text, classes) {
      if (classes == null) {
        classes = '';
      }
      return $('<label>', {
        "class": classes,
        text: text
      });
    },
    input: function(classes, functions, type, val) {
      var $input, func, funcType;
      $input = $('<input>', {
        "class": classes,
        type: type,
        val: val
      });
      for (funcType in functions) {
        if (!__hasProp.call(functions, funcType)) continue;
        func = functions[funcType];
        $input.bind(funcType, func);
      }
      return $input;
    },
    button: function(funcName, func, value, classes) {
      if (classes == null) {
        classes = '';
      }
      return $('<input>', {
        "class": "button " + classes,
        click: func,
        id: "" + funcName + "Button",
        type: 'button',
        val: value
      });
    },
    form: {
      ket: function(states, elements) {
        var $input, $label, focus, initKet, state, _i;
        if (elements == null) {
          elements = [];
        }
        for (state = _i = 0; 0 <= states ? _i < states : _i > states; state = 0 <= states ? ++_i : --_i) {
          $label = create.label("State " + state, 'probLabel');
          focus = function() {
            clear.input($(this), '(Complex probability - a ± bi)');
            return info("INPUT THE PROBABILITY THAT THIS KET IS IN STATE " + ($(this).data('state')) + " IN THE FORM a ± bi.");
          };
          $input = create.input('stateProb', {
            focus: focus
          }, 'text', '(Complex probability - a ± bi)');
          $input.data('state', state);
          elements.push([$label, ':', $input, '<br/>']);
        }
        initKet = function() {
          var col, e, _ref;
          _ref = (function() {
            var $inp, complex, e;
            return [
              (function() {
                var _j, _len, _ref, _results;
                _ref = $('.stateProb');
                _results = [];
                for (_j = 0, _len = _ref.length; _j < _len; _j++) {
                  $inp = _ref[_j];
                  try {
                    complex = new $C($($inp).val());
                  } catch (error) {
                    err("BAD INPUT FOR STATE " + ($($inp).data('state')) + ". SHOULD BE A COMPLEX PROBABILITY IN THE FORM a ± bi.");
                    e = error;
                  }
                  _results.push(complex);
                }
                return _results;
              })(), e
            ];
          })(), col = _ref[0], e = _ref[1];
          if (!(e != null)) {
            create.ket(col, $('#ketName').val());
            $('#ketName').val('φ');
            clear.element($('#ketProbs'));
            return clear.input($('#ketQubits'));
          }
        };
        return $('#ketProbs').append(_.flatten([elements, create.button('createKet', initKet, 'create ket')]));
      },
      gate: function(states) {
        var $input, $table, $td, $tr, focus, i, initGate, j, _i, _j;
        $table = $('<table>');
        for (i = _i = 0; 0 <= states ? _i < states : _i > states; i = 0 <= states ? ++_i : --_i) {
          $tr = $('<tr>');
          for (j = _j = 0; 0 <= states ? _j < states : _j > states; j = 0 <= states ? ++_j : --_j) {
            focus = function() {
              clear.input($(this), '(a ± bi)');
              return info("INPUT THE VALUE FOR THIS GATE AT INDEX [" + ($(this).data('i')) + "][" + ($(this).data('j')) + "] IN THE FORM a ± bi.");
            };
            $input = create.input('gateVal', {
              focus: focus
            }, 'text', '(a ± bi)');
            $input.data('i', i);
            $input.data('j', j);
            $td = $('<td>', {
              html: $input
            });
            $tr.append($td);
          }
          $table.append($tr);
        }
        initGate = function() {
          var e, m, _ref;
          states = Math.pow(2, $('#gateQubits').val());
          _ref = (function(m) {
            var $inp, complex, e, s, _k;
            if (m == null) {
              m = [];
            }
            for (s = _k = 0; 0 <= states ? _k < states : _k > states; s = 0 <= states ? ++_k : --_k) {
              m.push([]);
            }
            return [
              ((function() {
                var _l, _len, _ref;
                _ref = $('.gateVal');
                for (_l = 0, _len = _ref.length; _l < _len; _l++) {
                  $inp = _ref[_l];
                  i = $($inp).data('i');
                  j = $($inp).data('j');
                  try {
                    complex = new $C($($inp).val());
                  } catch (error) {
                    err("BAD INPUT FOR [" + i + "][" + j + "]. SHOULD BE A COMPLEX NUMBER IN THE FORM a ± bi.");
                    e = error;
                  }
                  m[i][j] = complex;
                }
                return m;
              })()), e
            ];
          })(), m = _ref[0], e = _ref[1];
          if (!(e != null)) {
            create.gate(m, $('#gateName').val());
            $('#gateName').val('M');
            clear.element($('#gateVals'));
            return clear.input($('#gateQubits'));
          }
        };
        return $('#gateVals').append($table, create.button('createGate', initGate, 'create gate'));
      },
      deutsch: function() {
        var $description, $select;
        $description = $('#deutschDescription');
        $description.show();
        $select = $description.find('div select');
        selectReset($select);
        return $select.change(function() {
          var $parent, clearQuantum, run, runFunction;
          if ($select.children('option').first().text() === 'SELECT:') {
            $select.children('option').first().remove();
          }
          $parent = $description.parent();
          $parent.children('input').remove();
          $('.answer').remove();
          clearQuantum = create.button('clearQuantum', clear.quantum, 'clear computer');
          runFunction = function() {
            info("THINKING...");
            $('.overlay').css({
              display: 'block'
            }).animate({
              opacity: 0.8
            });
            return $('.overlay').promise().done(function() {
              var $selected, answerStr, oracle;
              $selected = $select.children('option:selected');
              oracle = $U.CreateNBitDeutschJozsaOracle(1, +$selected.val());
              answerStr = "" + ($selected.text()) + " is %s";
              runAlgorithm(Quantum.Deutsch, [oracle], answerStr, 'DEUTSCH');
              return $('.overlay').animate({
                opacity: 0
              }, function() {
                return $(this).css({
                  display: 'none'
                });
              });
            });
          };
          run = create.button('runAlgorithm', runFunction, 'run algorithm');
          $parent = $description.parent();
          $parent.children('input').remove();
          return $parent.append([clearQuantum, run]);
        });
      },
      deutschJozsa: function() {
        var $description, $select;
        $description = $('#deutschJozsaDescription');
        $description.show();
        $select = $description.find('div select');
        $('#createFunction').remove();
        selectReset($select);
        return $select.change(function() {
          var $div, $parent, clearQuantum, elements, i, n, run, runFunction, valSelect, _i, _ref;
          if ($select.children('option').first().text() === 'SELECT:') {
            $select.children('option').first().remove();
          }
          $(this).parent().siblings('div').remove();
          $div = $('<div>', {
            id: 'createFunction'
          });
          elements = [];
          n = +$select.children('option:selected').val();
          elements.push("<p class='title'>CREATE FUNCTION:</p>");
          for (i = _i = 0, _ref = Math.pow(2, n); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            elements.push(create.label("ƒ(" + i + ") = "));
            valSelect = $('<select>', {
              "class": 'valSelect'
            });
            valSelect.append($('<option>', {
              value: 0,
              text: 0
            }));
            valSelect.append($('<option>', {
              value: 1,
              text: 1
            }));
            elements.push([valSelect]);
            if (i % 2 === 1) {
              elements.push('<br/>');
            }
          }
          $div.append(_.flatten(elements));
          $description.append($div);
          $('.answer').remove();
          clearQuantum = create.button('clearAlgorithm', clear.quantum, 'clear computer');
          runFunction = function() {
            info("THINKING...");
            $('.overlay').css({
              display: 'block'
            }).animate({
              opacity: 0.8
            });
            return $('.overlay').promise().done(function() {
              var $selected, answerStr, el, one, oracle, vals, value, zero;
              $selected = $('.valSelect option:selected');
              vals = (function() {
                var _j, _len, _results;
                _results = [];
                for (_j = 0, _len = $selected.length; _j < _len; _j++) {
                  el = $selected[_j];
                  _results.push($(el).text());
                }
                return _results;
              })();
              value = parseInt(vals.join(''), 2);
              oracle = $U.CreateNBitDeutschJozsaOracle(n, value);
              zero = (function() {
                var _j, _ref1, _results;
                _results = [];
                for (i = _j = 0, _ref1 = vals.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                  if (vals[i] === '0') {
                    _results.push(i);
                  }
                }
                return _results;
              })();
              one = (function() {
                var _j, _ref1, _results;
                _results = [];
                for (i = _j = 0, _ref1 = vals.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                  if (vals[i] === '1') {
                    _results.push(i);
                  }
                }
                return _results;
              })();
              answerStr = '';
              if (zero.length > 0) {
                answerStr += "ƒ(" + zero + ") = 0";
              }
              if (zero.length > 0 && one.length > 0) {
                answerStr += ', ';
              }
              if (one.length > 0) {
                answerStr += "ƒ(" + one + ") = 1";
              }
              answerStr += ' is %s';
              runAlgorithm(Quantum.DeutschJozsa, [oracle, n], answerStr, 'DEUTSCH-JOZSA');
              return $('.overlay').animate({
                opacity: 0
              }, function() {
                return $(this).css({
                  display: 'none'
                });
              });
            });
          };
          run = create.button('runAlgorithm', runFunction, 'run algorithm');
          $parent = $description.parent();
          $parent.children('input').remove();
          return $parent.append([clearQuantum, run]);
        });
      },
      grovers: function() {
        var $description, $select;
        $description = $('#groversDescription');
        $description.show();
        $select = $description.find('div select');
        $('#selectSolution').remove();
        selectReset($select);
        return $select.change(function() {
          var $div, $parent, clearQuantum, elements, i, n, run, runFunction, solutionSelect, str, _i, _ref;
          if ($select.children('option').first().text() === 'SELECT:') {
            $select.children('option').first().remove();
          }
          $(this).parent().siblings('div').remove();
          $div = $('<div>', {
            id: 'selectSolution'
          });
          elements = [];
          n = +$select.children('option:selected').val();
          elements.push("<p class='title'>SELECT SOLUTION:</p>");
          elements.push(create.label("Solution:"));
          solutionSelect = $('<select>', {
            "class": 'solutionSelect'
          });
          for (i = _i = 0, _ref = Math.pow(2, n); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            str = i.toString(2);
            while (str.length < n) {
              str = "0" + str;
            }
            solutionSelect.append($('<option>', {
              value: i,
              text: "'" + str + "'"
            }));
          }
          $div.append(_.flatten([elements, solutionSelect, '<br/>']));
          $description.append($div);
          $('.answer').remove();
          clearQuantum = create.button('clearAlgorithm', clear.quantum, 'clear computer');
          runFunction = function() {
            info("THINKING...");
            $('.overlay').css({
              display: 'block'
            }).animate({
              opacity: 0.8
            });
            return $('.overlay').promise().done(function() {
              var answerStr, oracle, sol;
              sol = +$('.solutionSelect option:selected').val();
              oracle = $U.CreateNBitHaystack(n, sol);
              answerStr = "The solution is %s";
              runAlgorithm(Quantum.Grover, [oracle], answerStr, 'GROVER\'S');
              return $('.overlay').animate({
                opacity: 0
              }, function() {
                return $(this).css({
                  display: 'none'
                });
              });
            });
          };
          run = create.button('runAlgorithm', runFunction, 'run algorithm');
          $parent = $description.parent();
          $parent.children('input').remove();
          return $parent.append([clearQuantum, run]);
        });
      },
      shors: function() {
        var $description, $div, $select, i, j, n, p, primes, _i, _j, _k, _l, _ref, _ref1, _ref2;
        $description = $('#shorsDescription');
        $description.show();
        $description.find('div select').remove();
        $description.find('label').remove();
        $div = $description.children('div');
        for (p = _i = 1; _i <= 2; p = ++_i) {
          $select = $('<select>');
          $select.append($('<option>', {
            text: 'SELECT:'
          }));
          primes = (function() {
            var _j, _results;
            _results = [];
            for (n = _j = 0; _j <= 600; n = ++_j) {
              _results.push(true);
            }
            return _results;
          })();
          primes[0] = false;
          primes[1] = false;
          for (i = _j = 2, _ref = Math.sqrt(600); 2 <= _ref ? _j <= _ref : _j >= _ref; i = 2 <= _ref ? ++_j : --_j) {
            if (primes[i]) {
              for (j = _k = _ref1 = Math.pow(i, 2); _ref1 <= 600 ? _k <= 600 : _k >= 600; j = _k += i) {
                primes[j] = false;
              }
            }
          }
          for (i = _l = 0, _ref2 = primes.length; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
            if (primes[i]) {
              $select.append($('<option>', {
                val: i,
                text: i
              }));
            }
          }
          $div.append([create.label("Prime " + p + ": "), $select, "<br/>"]);
        }
        $select = $description.find('div select');
        return $select.change(function() {
          var $parent, p1, p2, product, run, runFunction;
          if ($(this).children('option').first().text() === 'SELECT:') {
            $(this).children('option').first().remove();
          }
          p1 = $(this).parent().find('select option:selected')[0].value;
          p2 = $(this).parent().find('select option:selected')[1].value;
          if (p1 !== 'SELECT:' && p2 !== 'SELECT:') {
            product = +p1 * +p2;
            $(this).siblings('.subtitle').remove();
            $(this).parent().append("<p class='subtitle'><br/>" + p1 + " × " + p2 + " = " + product + "<br/></p>");
            $('.answer').remove();
            runFunction = function() {
              info("THINKING...");
              $('.overlay').css({
                display: 'block'
              }).animate({
                opacity: 0.8
              });
              return $('.overlay').promise().done(function() {
                var answerStr;
                answerStr = "%s is a prime factor of " + product;
                runAlgorithm(Quantum.Shor, [product], answerStr, 'SHOR\'S');
                return $('.overlay').animate({
                  opacity: 0
                }, function() {
                  return $(this).css({
                    display: 'none'
                  });
                });
              });
            };
            run = create.button('runAlgorithm', runFunction, 'run algorithm');
            $parent = $description.parent();
            $parent.children('input').remove();
            return $parent.append(run);
          }
        });
      }
    },
    ket: function(col, name) {
      var $ketDiv, copyName, count, ket, key, val, _ref;
      ket = new $K(col);
      info("KET CREATED - UPDATING QUANTUM COMPUTER STATE.");
      if (name === '') {
        name = 'φ';
      }
      count = 0;
      copyName = name === 'φ' ? "" + name + "<sub>" + count + "</sub>" : name;
      if (copyName.indexOf('<sub>' < 0 && copyName.indexOf('</sub>' < 0))) {
        copyName = "" + copyName + sub;
      }
      _ref = quantumComputer.kets;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        val = _ref[key];
        if (key === copyName) {
          copyName = "" + name + "<sub>" + (++count) + "</sub>";
        }
      }
      name = "" + copyName;
      ket.name = name;
      quantumComputer.kets[name] = ket;
      $ketDiv = $('<div>', {
        "class": 'ket'
      });
      display.ket(ket, $ketDiv);
      $('#kets').append($ketDiv).masonry('appended', $ketDiv).masonry('reload');
      return $('#kets').promise().done(function() {
        return $(this).css({
          overflow: ''
        });
      });
    },
    gate: function(m, name) {
      var $gateDiv, copyName, count, gate, key, type, val, _ref;
      gate = new $M(m);
      type = 'GATE';
      if (gate.isUnitary()) {
        type = 'UNITARY GATE';
      }
      if (gate.isHermitian()) {
        type = 'HERMITIAN GATE';
      }
      if (gate.isIdentity()) {
        type = 'IDENTITY GATE';
      }
      info("" + type + " CREATED - UPDATING QUANTUM COMPUTER STATE.");
      if (name === '') {
        name = 'M';
      }
      count = 0;
      copyName = name === 'M' ? "" + name + "<sub>" + count + "</sub>" : name;
      if (copyName.indexOf('<sub>' < 0 && copyName.indexOf('</sub>' < 0))) {
        copyName = "" + copyName + sub;
      }
      _ref = quantumComputer.gates;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        val = _ref[key];
        if (key === copyName) {
          copyName = "" + name + "<sub>" + (++count) + "</sub>";
        }
      }
      name = "" + copyName;
      gate.name = name;
      quantumComputer.gates[name] = gate;
      $gateDiv = $('<div>', {
        "class": 'gate'
      });
      display.gate(gate, $gateDiv);
      $('#gates').append($gateDiv).masonry('appended', $gateDiv).masonry('reload');
      return $('#gates').promise().done(function() {
        return $(this).css({
          overflow: ''
        });
      });
    }
  };

  display = {
    draggable: function($div, dragClass) {
      return $div.draggable({
        revert: true,
        start: function() {
          return $(this).addClass(dragClass);
        },
        stop: function() {
          return $(this).removeClass(dragClass);
        }
      });
    },
    ket: function(ket, $div, elements) {
      var binLength, binary, del, deleteButton, i, normalise, normaliseButton, prob, _i, _ref;
      if (elements == null) {
        elements = [];
      }
      clear.element($($div));
      elements.push("<span class='name'>" + ket.name + "</span><br/>");
      binLength = Math.log(ket.col.length) / Math.LN2;
      for (i = _i = 0, _ref = ket.col.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        binary = i.toString(2);
        while (binary.length < binLength) {
          binary = 0 + binary;
        }
        elements.push("<span>" + binary + "</span>: ");
        prob = $('<span>', {
          "class": 'complexProb',
          id: "complexProb" + i,
          mouseenter: function() {
            var id, name;
            id = $(this).attr('id').substr(11);
            name = $(this).siblings('.name').html();
            prob = quantumComputer.kets[name].probability(id).toFixed(5);
            return $(this).html("p(x) = " + prob);
          },
          mouseleave: function() {
            var compProb, id, name;
            id = $(this).attr('id').substr(11);
            name = $(this).siblings('.name').html();
            compProb = quantumComputer.kets[name].col[id];
            return $(this).html("" + compProb);
          },
          text: "" + ket.col[i]
        });
        elements.push([prob, "<br/>"]);
      }
      normalise = function() {
        var name;
        name = $(this).siblings('.name').html();
        quantumComputer.kets[name].normalise();
        ket = quantumComputer.kets[name];
        display.ket(ket, $(this).parent());
        $('#kets').masonry('reload');
        return info("KET " + name + " HAS BEEN NORMALISED.");
      };
      normaliseButton = create.button("" + name + "Normalise", normalise, 'normalise');
      del = function() {
        var $ketDiv, name;
        name = $(this).siblings('.name').html();
        ket = quantumComputer.kets[name];
        quantumComputer.kets[name] = null;
        $ketDiv = $(this).parent();
        $('#kets').masonry('remove', $ketDiv).masonry('reload');
        return info("KET " + name + " HAS BEEN DELETED.");
      };
      deleteButton = create.button("" + name + "Delete", del, 'delete', 'red');
      $div.append(_.flatten([elements, normaliseButton, deleteButton]));
      return display.draggable($div, 'draggingKet');
    },
    gate: function(gate, $div, elements) {
      var del, deleteButton, matrixSpan, view, viewButton;
      if (elements == null) {
        elements = [];
      }
      clear.element($($div));
      elements.push("<span class='name'>" + gate.name + "</span>");
      matrixSpan = function(type) {
        return $('<span>', {
          "class": "matrixType " + type,
          text: type[0].toUpperCase(),
          mouseover: function() {
            return info("THIS GATE IS " + (type.toUpperCase()));
          }
        });
      };
      if (gate.isUnitary()) {
        elements.push(matrixSpan('unitary'));
      }
      if (gate.isHermitian()) {
        elements.push(matrixSpan('hermitian'));
      }
      if (gate.isIdentity()) {
        elements.push(matrixSpan('identity'));
      }
      elements.push("<br/>");
      view = function() {
        return display.matrix(this);
      };
      viewButton = create.button("" + name + "View", view, 'view matrix');
      del = function() {
        var $gateDiv, name;
        name = $(this).siblings('.name').html();
        gate = quantumComputer.gates[name];
        quantumComputer.gates[name] = null;
        $gateDiv = $(this).parent();
        $('#gates').masonry('remove', $gateDiv).masonry('reload');
        return info("GATE " + name + " HAS BEEN DELETED.");
      };
      deleteButton = create.button("" + name + "Delete", del, 'delete', 'red');
      $div.append(_.flatten([elements, viewButton, deleteButton]));
      return display.draggable($div, 'draggingGate');
    },
    matrix: function(el) {
      var $table, $td, $tr, gate, i, j, name, _i, _j, _ref, _ref1;
      name = $(el).siblings('.name').html();
      gate = quantumComputer.gates[name];
      $table = $('<table>');
      for (i = _i = 0, _ref = gate.size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        $tr = $('<tr>');
        for (j = _j = 0, _ref1 = gate.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          $td = $('<td>', {
            html: "<p>" + gate.matrix[i][j] + "</p>",
            mouseover: function() {
              name = $('.matrix').data('name');
              gate = quantumComputer.gates[name];
              i = $(this).data('i');
              j = $(this).data('j');
              return infoBar('#matrixInfo', 'info', "" + name + " HAS VALUE " + gate.matrix[i][j] + " AT [" + i + "][" + j + "]");
            }
          });
          $td.css({
            width: "" + (100 / gate.matrix.length) + "%",
            minWidth: '50px'
          });
          $td.data('i', i);
          $td.data('j', j);
          $tr.append($td);
        }
        $table.append($tr);
      }
      return $('.overlay').css({
        display: 'block'
      }).animate({
        opacity: 0.8
      }, function() {
        var $matrix, elements, margin, matrixWidth, maxWidth, minWidth, width;
        $('.matrix').remove();
        elements = [];
        width = $('#wrapper').width();
        minWidth = 400;
        maxWidth = width * 0.6;
        matrixWidth = gate.matrix.length * 100;
        matrixWidth = matrixWidth > maxWidth ? maxWidth : matrixWidth;
        matrixWidth = matrixWidth < minWidth ? minWidth : matrixWidth;
        margin = (width - matrixWidth - 100) / 2;
        $matrix = $('<div>', {
          "class": 'matrix',
          css: {
            margin: "10% " + margin + "px",
            width: matrixWidth
          }
        });
        $('#wrapper').append($matrix);
        $matrix.data('name', name);
        elements.push($('<div>', {
          "class": 'default',
          id: 'matrixInfo'
        }));
        elements.push($('<div>', {
          "class": 'table',
          html: $table
        }));
        elements.push($('<input>', {
          "class": 'button red',
          click: function() {
            $('.matrix').html('');
            $('.matrix').remove();
            return $('.overlay').animate({
              opacity: 0
            }, function() {
              return $(this).css({
                display: 'none'
              });
            });
          },
          id: "closeViewMatrixButton",
          type: 'button',
          val: "close"
        }));
        $matrix.append(elements);
        return infoBar('#matrixInfo', 'info', "" + ($matrix.data('name')));
      });
    }
  };

  select = {
    algorithm: function() {
      var name;
      $('.description').hide();
      $('.description').parent().children('input').remove();
      $('.answer').remove();
      name = $('#algorithms form').children('select').children(':selected').text();
      switch (name) {
        case 'Deutsch':
          return create.form.deutsch();
        case 'Deutsch-Josza':
          return create.form.deutschJozsa();
        case 'Grover\'s':
          return create.form.grovers();
        case 'Shor\'s':
          return create.form.shors();
      }
    },
    gate: function() {
      var $form, gateType;
      gateType = function() {
        var m, name;
        name = $('#gateSelect option:selected').text();
        switch (name) {
          case 'PauliX':
            m = $U.PauliX().matrix;
            break;
          case 'PauliY':
            m = $U.PauliY().matrix;
            break;
          case 'PauliZ':
            m = $U.PauliZ().matrix;
            break;
          case 'S':
            m = $U.S().matrix;
            break;
          case 'T':
            m = $U.T().matrix;
            break;
          case '√Not':
            m = $U.SqrtNot().matrix;
            break;
          case 'Hadamard':
            m = $U.Hadamard().matrix;
        }
        return create.gate(m, name);
      };
      $form = $('#createSetGateForm');
      $form.children('input').remove();
      return $form.append(create.button('createSelectedGate', gateType, 'create gate'));
    },
    ket: function() {
      var $form, ketType;
      ketType = function() {
        var k, name;
        name = $('#ketSelect option:selected').text();
        switch (name) {
          case 'Zero':
            k = $K.Zero().col;
            break;
          case 'One':
            k = $K.One().col;
        }
        return create.ket(k, name);
      };
      $form = $('#createSetKetForm');
      $form.children('input').remove();
      return $form.append(create.button('createSelectedKet', ketType, 'create ket'));
    }
  };

  transition = [null, null];

  apply = {
    gate: null,
    ket: null
  };

  kron = [null, null];

  drop = {
    transition: function($el) {
      var ket, name, transitionAmplitude;
      name = $('.draggingKet').find('.name').html();
      ket = quantumComputer.kets[name];
      if ($el.attr('id') === 'transition1Drop') {
        transition[0] = ket;
      }
      if ($el.attr('id') === 'transition2Drop') {
        transition[1] = ket;
      }
      info("KET " + ket.name + " HAS BEEN DROPPED ONTO TRANSITION AMPLITUDE.");
      $el.addClass('dropped').html(name);
      if ((transition[0] != null) && (transition[1] != null)) {
        $('.transitionAmp').remove();
        if (transition[0].size === transition[1].size) {
          transitionAmplitude = transition[0].transition(transition[1]);
          $el.parent().append($('<p>', {
            "class": 'transitionAmp',
            html: "The Transition Amplitude from " + transition[0].name + " to " + transition[1].name + " is " + transitionAmplitude + "."
          }));
        } else {
          err("CANNOT COMPUTER TRANSITION AMPLITUDE FROM " + transition[0].name + " TO " + transition[1].name + ". THEY HAVE DIFFERENENT NUMBERS OF QUBITS.");
        }
      }
      $('#clearTransitionButton').remove();
      return $el.parent().append(create.button('clearTransition', clear.transition, 'clear', 'red'));
    },
    apply: {
      buttons: function($parent) {
        var applyExistingKet, applyNewKet;
        $parent.children('input').remove();
        applyNewKet = function() {
          var gateName, ketName;
          gateName = apply.gate.name.replace('<sub> </sub>', '');
          ketName = apply.ket.name.replace('<sub> </sub>', '');
          if (apply.gate.size === apply.ket.col.length) {
            create.ket($K.ApplyGate(apply.gate, apply.ket).col, "" + gateName + " → (" + ketName + ")");
            return info("" + gateName + " HAS BEEN APPLIED TO " + ketName + " RESULTING IN " + gateName + "->(" + ketName + ").");
          } else {
            return err("" + gateName + " CANNOT BE APPLIED TO " + ketName + ". ROW/COLUMN SIZES MUST MATCH.");
          }
        };
        applyExistingKet = function() {
          var $div, name;
          if (apply.gate.size === apply.ket.col.length) {
            name = apply.ket.name;
            apply.ket = $K.ApplyGate(apply.gate, apply.ket);
            apply.ket.name = name;
            $div = $(".ket span.name").filter(function() {
              return $(this).html() === apply.ket.name;
            }).parent();
            display.ket(apply.ket.normalise(), $div);
            quantumComputer.kets[apply.ket.name] = apply.ket;
            return info("" + apply.gate.name + " HAS BEEN APPLIED TO " + apply.ket.name + ".");
          } else {
            return err("" + apply.gate.name + " CANNOT BE APPLIED TO " + apply.ket.name + ". ROW/COLUMN SIZES MUST MATCH.");
          }
        };
        $parent.append(create.button('applyNewKet', applyNewKet, 'new ket', 'half'));
        return $parent.append(create.button('applyExistingKet', applyExistingKet, 'existing ket', 'half'));
      },
      gate: function($el) {
        var gate, name;
        name = $('.draggingGate').find('.name').html();
        gate = quantumComputer.gates[name];
        apply.gate = gate;
        info("GATE " + name + " HAS BEEN DROPPED ONTO APPLY GATE.");
        $el.addClass('dropped').html("" + name);
        $el.parent().children('input').remove();
        if ((apply.gate != null) && (apply.ket != null)) {
          drop.apply.buttons($el.parent());
        }
        return $el.parent().append(create.button('clearApply', clear.apply, 'clear', 'red'));
      },
      ket: function($el) {
        var ket, name;
        name = $('.draggingKet').find('.name').html();
        ket = quantumComputer.kets[name];
        apply.ket = ket;
        info("KET " + name + " HAS BEEN DROPPED ONTO APPLY GATE.");
        $el.addClass('dropped').html(name);
        $el.parent().children('input').remove();
        if ((apply.gate != null) && (apply.ket != null)) {
          drop.apply.buttons($el.parent());
        }
        return $el.parent().append(create.button('clearApply', clear.apply, 'clear', 'red'));
      }
    },
    kron: function($el) {
      var button, gate, name;
      button = function($parent) {
        var kronInit;
        $parent.children('input').remove();
        kronInit = function() {
          var kron0Name, kron1Name;
          kron0Name = kron[0].name.replace('<sub> </sub>', '');
          kron1Name = kron[1].name.replace('<sub> </sub>', '');
          if (kron[0].size * kron[1].size > 128) {
            return warn("CREATING " + kron0Name + "⊗" + kron1Name + " WILL TAKE A LONG TIME (AND MIGHT EVEN CRASH YOUR COMPUTER). TRY SOME SMALLER GATES.");
          } else {
            info("THINKING...");
            $('.overlay').css({
              display: 'block'
            }).animate({
              opacity: 0.8
            });
            return $('.overlay').promise().done(function() {
              create.gate($M.Kron([kron[0], kron[1]]).matrix, "" + kron0Name + "⊗" + kron1Name);
              $('.overlay').animate({
                opacity: 0
              }, function() {
                return $(this).css({
                  display: 'none'
                });
              });
              return info("THE KRONECKER PRODUCT OF " + kron0Name + " & " + kron1Name + " IS " + kron0Name + "⊗" + kron1Name + ".");
            });
          }
        };
        return $parent.append(create.button('kron', kronInit, 'kron'));
      };
      name = $('.draggingGate').find('.name').html();
      gate = quantumComputer.gates[name];
      if ($el.attr('id') === 'kron1Drop') {
        kron[0] = gate;
      }
      if ($el.attr('id') === 'kron2Drop') {
        kron[1] = gate;
      }
      info("GATE " + name + " HAS BEEN DROPPED ONTO KRONECKER PRODUCT.");
      $el.addClass('dropped').html("" + name);
      if ((kron[0] != null) && (kron[1] != null)) {
        button($el.parent());
      }
      $('#clearKronButton').remove();
      return $el.parent().append(create.button('clearKron', clear.kron, 'clear', 'red'));
    }
  };

  $(function() {
    var changeHandle, dropDiv, focusClear, focusInfo, keyupCheck, masonryDiv;
    focusClear = function($input, def) {
      return $input.focus(function() {
        return clear.input($(this), def);
      });
    };
    focusClear($('#ketName'), 'φ');
    focusClear($('#gateName'), 'M');
    focusInfo = function($input, infoMes) {
      return $input.focus(function() {
        return info(infoMes);
      });
    };
    focusInfo($('#ketQubits'), 'INPUT THE NUMBER OF QUBITS FOR THIS KET E.G. \'2\'.');
    focusInfo($('#gateQubits'), 'INPUT THE NUMBER OF QUBITS FOR THIS GATE E.G. \'2\'.');
    keyupCheck = function($input, func, maxVal, success, type) {
      return $input.keyup(function() {
        var val;
        clearInfoBar();
        clear.element($input.next('div'));
        val = $(this).val();
        return func(val, maxVal, success, type);
      });
    };
    keyupCheck($('#ketQubits'), checkInput.qubit, 4, create.form.ket, 'KET');
    keyupCheck($('#gateQubits'), checkInput.qubit, 2, create.form.gate, 'GATE');
    changeHandle = function($select, func) {
      return $select.change(function() {
        var $firstOption;
        $firstOption = $select.children('option').first();
        if ($firstOption.text() === 'SELECT:') {
          $firstOption.remove();
        }
        return func();
      });
    };
    changeHandle($('#gateSelect'), select.gate);
    changeHandle($('#ketSelect'), select.ket);
    changeHandle($('#algorithms form').children('select'), select.algorithm);
    masonryDiv = function($div, itemClass) {
      return $div.masonry({
        isAnimated: true,
        itemSelector: itemClass,
        columWidth: 1
      });
    };
    masonryDiv($('#kets'), '.ket');
    masonryDiv($('#gates'), '.gate');
    dropDiv = function($div, accept, func) {
      return $div.droppable({
        accept: accept,
        activeClass: 'drag',
        hoverClass: 'over',
        drop: function() {
          return func($(this));
        }
      });
    };
    dropDiv($('.transition'), '.ket', drop.transition);
    dropDiv($('#ketDrop'), '.ket', drop.apply.ket);
    dropDiv($('#gateDrop'), '.gate', drop.apply.gate);
    dropDiv($('.kron'), '.gate', drop.kron);
    $('#clearQuantumComputer').click(function() {
      return clear.quantum();
    });
    return $(window).resize(function() {
      return $('.state').css({
        overflow: ''
      });
    });
  });

}).call(this);
